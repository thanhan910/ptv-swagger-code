/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * PTV Timetable API - Version 3
 * The PTV Timetable API provides direct access to Public Transport Victoria's public transport timetable data.    The API returns scheduled timetable, route and stop data for all metropolitan and regional train, tram and bus services in Victoria, including Night Network(Night Train and Night Tram data are included in metropolitan train and tram services data, respectively, whereas Night Bus is a separate route type).    The API also returns real-time data for metropolitan train, tram and bus services (where this data is made available to PTV), as well as disruption information, stop facility information, and access to myki ticket outlet data.    This Swagger is for Version 3 of the PTV Timetable API. By using this documentation you agree to comply with the licence and terms of service.    Train timetable data is updated daily, while the remaining data is updated weekly, taking into account any planned timetable changes (for example, due to holidays or planned disruptions). The PTV timetable API is the same API used by PTV for its apps. To access the most up to date data PTV has (including real-time data) you must use the API dynamically.    You can access the PTV Timetable API through a HTTP or HTTPS interface, as follows:        base URL / version number / API name / query string  The base URL is either:    *  http://timetableapi.ptv.vic.gov.au  or    *  https://timetableapi.ptv.vic.gov.au    The Swagger JSON file is available at http://timetableapi.ptv.vic.gov.au/swagger/docs/v3    Frequently asked questions are available on the PTV website at http://ptv.vic.gov.au/apifaq    Links to the following information are also provided on the PTV website at http://ptv.vic.gov.au/ptv-timetable-api/  * How to register for an API key and calculate a signature  * PTV Timetable API V2 to V3 Migration Guide  * PTV Timetable API Data Quality Statement    All information about how to use the API is in this documentation. PTV cannot provide technical support for the API.  
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://timetableapi.ptv.vic.gov.au".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration?: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface V3BulkDeparturesRequest
 */
export interface V3BulkDeparturesRequest {
    /**
     * Collection of departure requests
     * @type {Array<V3StopDepartureRequest>}
     * @memberof V3BulkDeparturesRequest
     */
    requests: Array<V3StopDepartureRequest>;
    /**
     * Filter by the date and time of the request (ISO 8601 UTC format) (default = current date and time)
     * @type {Date}
     * @memberof V3BulkDeparturesRequest
     */
    dateUtc?: Date;
    /**
     * Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default = false). Requires max_results &gt; 0.
     * @type {boolean}
     * @memberof V3BulkDeparturesRequest
     */
    lookBackwards?: boolean;
    /**
     * Indicates if cancelled services (if they exist) are returned (default = false) - metropolitan train only
     * @type {boolean}
     * @memberof V3BulkDeparturesRequest
     */
    includeCancelled?: boolean;
    /**
     * Indicates if the route geopath should be returned
     * @type {boolean}
     * @memberof V3BulkDeparturesRequest
     */
    includeGeopath?: boolean;
    /**
     * List objects to be returned in full (i.e. expanded) - options include: all, stop, route, run, direction, disruption, none
     * @type {Array<string>}
     * @memberof V3BulkDeparturesRequest
     */
    expand?: Array<V3BulkDeparturesRequest.ExpandEnum>;
}

/**
 * @export
 * @namespace V3BulkDeparturesRequest
 */
export namespace V3BulkDeparturesRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ExpandEnum {
        All = <any> 'All',
        Stop = <any> 'Stop',
        Route = <any> 'Route',
        Run = <any> 'Run',
        Direction = <any> 'Direction',
        Disruption = <any> 'Disruption',
        VehicleDescriptor = <any> 'VehicleDescriptor',
        VehiclePosition = <any> 'VehiclePosition',
        None = <any> 'None'
    }
}

/**
 * 
 * @export
 * @interface V3BulkDeparturesResponse
 */
export interface V3BulkDeparturesResponse {
    /**
     * Contains departures for the requested stop and route(s). It includes details as to the route_direction and whether it is still valid.
     * @type {Array<V3BulkDeparturesUpdateResponse>}
     * @memberof V3BulkDeparturesResponse
     */
    responses?: Array<V3BulkDeparturesUpdateResponse>;
    /**
     * A train station, tram stop, bus stop, regional coach stop or Night Bus stop
     * @type {{ [key: string]: V3BulkDeparturesStopResponse; }}
     * @memberof V3BulkDeparturesResponse
     */
    stops?: { [key: string]: V3BulkDeparturesStopResponse; };
    /**
     * Train lines, tram routes, bus routes, regional coach routes, Night Bus routes
     * @type {Array<any>}
     * @memberof V3BulkDeparturesResponse
     */
    routes?: Array<any>;
    /**
     * Individual trips/services of a route
     * @type {Array<V3Run>}
     * @memberof V3BulkDeparturesResponse
     */
    runs?: Array<V3Run>;
    /**
     * Directions of travel of route
     * @type {Array<V3Direction>}
     * @memberof V3BulkDeparturesResponse
     */
    directions?: Array<V3Direction>;
    /**
     * Disruption information applicable to relevant routes or stops
     * @type {{ [key: string]: V3Disruption; }}
     * @memberof V3BulkDeparturesResponse
     */
    disruptions?: { [key: string]: V3Disruption; };
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3BulkDeparturesResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3BulkDeparturesRouteDirectionResponse
 */
export interface V3BulkDeparturesRouteDirectionResponse {
    /**
     * Route identifier
     * @type {string}
     * @memberof V3BulkDeparturesRouteDirectionResponse
     */
    routeId?: string;
    /**
     * Direction of travel identifier
     * @type {number}
     * @memberof V3BulkDeparturesRouteDirectionResponse
     */
    directionId?: number;
    /**
     * Name of direction of travel
     * @type {string}
     * @memberof V3BulkDeparturesRouteDirectionResponse
     */
    directionName?: string;
}

/**
 * 
 * @export
 * @interface V3BulkDeparturesStopResponse
 */
export interface V3BulkDeparturesStopResponse {
    /**
     * Name of stop
     * @type {string}
     * @memberof V3BulkDeparturesStopResponse
     */
    stopName?: string;
    /**
     * Stop identifier
     * @type {number}
     * @memberof V3BulkDeparturesStopResponse
     */
    stopId?: number;
    /**
     * Geographic coordinate of latitude at stop
     * @type {number}
     * @memberof V3BulkDeparturesStopResponse
     */
    stopLatitude?: number;
    /**
     * Geographic coordinate of longitude at stop
     * @type {number}
     * @memberof V3BulkDeparturesStopResponse
     */
    stopLongitude?: number;
    /**
     * suburb of stop
     * @type {string}
     * @memberof V3BulkDeparturesStopResponse
     */
    stopSuburb?: string;
    /**
     * Landmark in proximity of stop
     * @type {string}
     * @memberof V3BulkDeparturesStopResponse
     */
    stopLandmark?: string;
}

/**
 * 
 * @export
 * @interface V3BulkDeparturesUpdateResponse
 */
export interface V3BulkDeparturesUpdateResponse {
    /**
     * Timetabled and real-time service departures
     * @type {Array<V3Departure>}
     * @memberof V3BulkDeparturesUpdateResponse
     */
    departures?: Array<V3Departure>;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3BulkDeparturesUpdateResponse
     */
    routeType?: number;
    /**
     * Stop identifier
     * @type {number}
     * @memberof V3BulkDeparturesUpdateResponse
     */
    stopId?: number;
    /**
     * The route direction that these departures are for. Will be one of the requested route directions
     * @type {V3BulkDeparturesRouteDirectionResponse}
     * @memberof V3BulkDeparturesUpdateResponse
     */
    requestedRouteDirection?: V3BulkDeparturesRouteDirectionResponse;
    /**
     * The status of the route direction (changed | unchanged).  If changed, requests should change the requested_route_direction for the route_direction supplied.
     * @type {number}
     * @memberof V3BulkDeparturesUpdateResponse
     */
    routeDirectionStatus?: V3BulkDeparturesUpdateResponse.RouteDirectionStatusEnum;
    /**
     * The route direction found matching the requested_route_direction
     * @type {V3BulkDeparturesRouteDirectionResponse}
     * @memberof V3BulkDeparturesUpdateResponse
     */
    routeDirection?: V3BulkDeparturesRouteDirectionResponse;
}

/**
 * @export
 * @namespace V3BulkDeparturesUpdateResponse
 */
export namespace V3BulkDeparturesUpdateResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum RouteDirectionStatusEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}

/**
 * 
 * @export
 * @interface V3Departure
 */
export interface V3Departure {
    /**
     * Stop identifier
     * @type {number}
     * @memberof V3Departure
     */
    stopId?: number;
    /**
     * Route identifier
     * @type {number}
     * @memberof V3Departure
     */
    routeId?: number;
    /**
     * Numeric trip/service run identifier. Defaults to -1 when run identifier is Alphanumeric
     * @type {number}
     * @memberof V3Departure
     */
    runId?: number;
    /**
     * Alphanumeric trip/service run identifier
     * @type {string}
     * @memberof V3Departure
     */
    runRef?: string;
    /**
     * Direction of travel identifier
     * @type {number}
     * @memberof V3Departure
     */
    directionId?: number;
    /**
     * Disruption information identifier(s)
     * @type {Array<number>}
     * @memberof V3Departure
     */
    disruptionIds?: Array<number>;
    /**
     * Scheduled (i.e. timetabled) departure time and date in ISO 8601 UTC format
     * @type {Date}
     * @memberof V3Departure
     */
    scheduledDepartureUtc?: Date;
    /**
     * Real-time estimate of departure time and date in ISO 8601 UTC format
     * @type {Date}
     * @memberof V3Departure
     */
    estimatedDepartureUtc?: Date;
    /**
     * Indicates if the metropolitan train service is at the platform at the time of query; returns false for other modes
     * @type {boolean}
     * @memberof V3Departure
     */
    atPlatform?: boolean;
    /**
     * Platform number at stop (metropolitan train only; returns null for other modes)
     * @type {string}
     * @memberof V3Departure
     */
    platformNumber?: string;
    /**
     * Flag indicating special condition for run (e.g. RR Reservations Required, GC Guaranteed Connection, DOO Drop Off Only, PUO Pick Up Only, MO Mondays only, TU Tuesdays only, WE Wednesdays only, TH Thursdays only, FR Fridays only, SS School days only; ignore E flag)
     * @type {string}
     * @memberof V3Departure
     */
    flags?: string;
    /**
     * Chronological sequence for the departures in a run. Order ascendingly by this field to get chronological order (earliest first) of departures with the same run_ref. NOTE, this field is not always N+1 or N-1 of the previous or following departure. e.g 100, 200, 250, 300 instead of 1, 2, 3, 4
     * @type {number}
     * @memberof V3Departure
     */
    departureSequence?: number;
}

/**
 * 
 * @export
 * @interface V3DeparturesBroadParameters
 */
export interface V3DeparturesBroadParameters {
    /**
     * Filter by platform number at stop
     * @type {Array<number>}
     * @memberof V3DeparturesBroadParameters
     */
    platformNumbers?: Array<number>;
    /**
     * Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
     * @type {number}
     * @memberof V3DeparturesBroadParameters
     */
    directionId?: number;
    /**
     * Indicates that stop_id parameter will accept \"GTFS stop_id\" data
     * @type {boolean}
     * @memberof V3DeparturesBroadParameters
     */
    gtfs?: boolean;
    /**
     * Filter by the date and time of the request (ISO 8601 UTC format) (default = current date and time)
     * @type {Date}
     * @memberof V3DeparturesBroadParameters
     */
    dateUtc?: Date;
    /**
     * Maximum number of results returned
     * @type {number}
     * @memberof V3DeparturesBroadParameters
     */
    maxResults?: number;
    /**
     * Indicates if cancelled services (if they exist) are returned (default = false) - metropolitan train only
     * @type {boolean}
     * @memberof V3DeparturesBroadParameters
     */
    includeCancelled?: boolean;
    /**
     * Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default = false). Requires max_results &gt; 0.
     * @type {boolean}
     * @memberof V3DeparturesBroadParameters
     */
    lookBackwards?: boolean;
    /**
     * List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
     * @type {Array<string>}
     * @memberof V3DeparturesBroadParameters
     */
    expand?: Array<V3DeparturesBroadParameters.ExpandEnum>;
    /**
     * Indicates if the route geopath should be returned
     * @type {boolean}
     * @memberof V3DeparturesBroadParameters
     */
    includeGeopath?: boolean;
}

/**
 * @export
 * @namespace V3DeparturesBroadParameters
 */
export namespace V3DeparturesBroadParameters {
    /**
     * @export
     * @enum {string}
     */
    export enum ExpandEnum {
        All = <any> 'All',
        Stop = <any> 'Stop',
        Route = <any> 'Route',
        Run = <any> 'Run',
        Direction = <any> 'Direction',
        Disruption = <any> 'Disruption',
        VehicleDescriptor = <any> 'VehicleDescriptor',
        VehiclePosition = <any> 'VehiclePosition',
        None = <any> 'None'
    }
}

/**
 * 
 * @export
 * @interface V3DeparturesResponse
 */
export interface V3DeparturesResponse {
    /**
     * Timetabled and real-time service departures
     * @type {Array<V3Departure>}
     * @memberof V3DeparturesResponse
     */
    departures?: Array<V3Departure>;
    /**
     * A train station, tram stop, bus stop, regional coach stop or Night Bus stop
     * @type {{ [key: string]: V3StopModel; }}
     * @memberof V3DeparturesResponse
     */
    stops?: { [key: string]: V3StopModel; };
    /**
     * Train lines, tram routes, bus routes, regional coach routes, Night Bus routes
     * @type {{ [key: string]: any; }}
     * @memberof V3DeparturesResponse
     */
    routes?: { [key: string]: any; };
    /**
     * Individual trips/services of a route
     * @type {{ [key: string]: V3Run; }}
     * @memberof V3DeparturesResponse
     */
    runs?: { [key: string]: V3Run; };
    /**
     * Directions of travel of route
     * @type {{ [key: string]: V3Direction; }}
     * @memberof V3DeparturesResponse
     */
    directions?: { [key: string]: V3Direction; };
    /**
     * Disruption information applicable to relevant routes or stops
     * @type {{ [key: string]: V3Disruption; }}
     * @memberof V3DeparturesResponse
     */
    disruptions?: { [key: string]: V3Disruption; };
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3DeparturesResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3DeparturesSpecificParameters
 */
export interface V3DeparturesSpecificParameters {
    /**
     * Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
     * @type {number}
     * @memberof V3DeparturesSpecificParameters
     */
    directionId?: number;
    /**
     * Indicates that stop_id parameter will accept \"GTFS stop_id\" data
     * @type {boolean}
     * @memberof V3DeparturesSpecificParameters
     */
    gtfs?: boolean;
    /**
     * Filter by the date and time of the request (ISO 8601 UTC format) (default = current date and time)
     * @type {Date}
     * @memberof V3DeparturesSpecificParameters
     */
    dateUtc?: Date;
    /**
     * Maximum number of results returned
     * @type {number}
     * @memberof V3DeparturesSpecificParameters
     */
    maxResults?: number;
    /**
     * Indicates if cancelled services (if they exist) are returned (default = false) - metropolitan train only
     * @type {boolean}
     * @memberof V3DeparturesSpecificParameters
     */
    includeCancelled?: boolean;
    /**
     * Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default = false). Requires max_results &gt; 0.
     * @type {boolean}
     * @memberof V3DeparturesSpecificParameters
     */
    lookBackwards?: boolean;
    /**
     * List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
     * @type {Array<string>}
     * @memberof V3DeparturesSpecificParameters
     */
    expand?: Array<V3DeparturesSpecificParameters.ExpandEnum>;
    /**
     * Indicates if the route geopath should be returned
     * @type {boolean}
     * @memberof V3DeparturesSpecificParameters
     */
    includeGeopath?: boolean;
}

/**
 * @export
 * @namespace V3DeparturesSpecificParameters
 */
export namespace V3DeparturesSpecificParameters {
    /**
     * @export
     * @enum {string}
     */
    export enum ExpandEnum {
        All = <any> 'All',
        Stop = <any> 'Stop',
        Route = <any> 'Route',
        Run = <any> 'Run',
        Direction = <any> 'Direction',
        Disruption = <any> 'Disruption',
        VehicleDescriptor = <any> 'VehicleDescriptor',
        VehiclePosition = <any> 'VehiclePosition',
        None = <any> 'None'
    }
}

/**
 * 
 * @export
 * @interface V3Direction
 */
export interface V3Direction {
    /**
     * Direction of travel identifier
     * @type {number}
     * @memberof V3Direction
     */
    directionId?: number;
    /**
     * Name of direction of travel
     * @type {string}
     * @memberof V3Direction
     */
    directionName?: string;
    /**
     * Route identifier
     * @type {number}
     * @memberof V3Direction
     */
    routeId?: number;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3Direction
     */
    routeType?: number;
}

/**
 * 
 * @export
 * @interface V3DirectionWithDescription
 */
export interface V3DirectionWithDescription {
    /**
     * 
     * @type {string}
     * @memberof V3DirectionWithDescription
     */
    routeDirectionDescription?: string;
    /**
     * Direction of travel identifier
     * @type {number}
     * @memberof V3DirectionWithDescription
     */
    directionId?: number;
    /**
     * Name of direction of travel
     * @type {string}
     * @memberof V3DirectionWithDescription
     */
    directionName?: string;
    /**
     * Route identifier
     * @type {number}
     * @memberof V3DirectionWithDescription
     */
    routeId?: number;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3DirectionWithDescription
     */
    routeType?: number;
}

/**
 * 
 * @export
 * @interface V3DirectionsResponse
 */
export interface V3DirectionsResponse {
    /**
     * Directions of travel of route
     * @type {Array<V3DirectionWithDescription>}
     * @memberof V3DirectionsResponse
     */
    directions?: Array<V3DirectionWithDescription>;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3DirectionsResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3Disruption
 */
export interface V3Disruption {
    /**
     * Disruption information identifier
     * @type {number}
     * @memberof V3Disruption
     */
    disruptionId?: number;
    /**
     * Headline title summarising disruption information
     * @type {string}
     * @memberof V3Disruption
     */
    title?: string;
    /**
     * URL of relevant article on PTV website
     * @type {string}
     * @memberof V3Disruption
     */
    url?: string;
    /**
     * Description of the disruption
     * @type {string}
     * @memberof V3Disruption
     */
    description?: string;
    /**
     * Status of the disruption (e.g. \"Planned\", \"Current\")
     * @type {string}
     * @memberof V3Disruption
     */
    disruptionStatus?: string;
    /**
     * Type of disruption
     * @type {string}
     * @memberof V3Disruption
     */
    disruptionType?: string;
    /**
     * Date and time disruption information is published on PTV website, in ISO 8601 UTC format
     * @type {Date}
     * @memberof V3Disruption
     */
    publishedOn?: Date;
    /**
     * Date and time disruption information was last updated by PTV, in ISO 8601 UTC format
     * @type {Date}
     * @memberof V3Disruption
     */
    lastUpdated?: Date;
    /**
     * Date and time at which disruption begins, in ISO 8601 UTC format
     * @type {Date}
     * @memberof V3Disruption
     */
    fromDate?: Date;
    /**
     * Date and time at which disruption ends, in ISO 8601 UTC format (returns null if unknown)
     * @type {Date}
     * @memberof V3Disruption
     */
    toDate?: Date;
    /**
     * Route relevant to a disruption (if applicable)
     * @type {Array<V3DisruptionRoute>}
     * @memberof V3Disruption
     */
    routes?: Array<V3DisruptionRoute>;
    /**
     * Stop relevant to a disruption (if applicable)
     * @type {Array<V3DisruptionStop>}
     * @memberof V3Disruption
     */
    stops?: Array<V3DisruptionStop>;
    /**
     * 
     * @type {string}
     * @memberof V3Disruption
     */
    colour?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V3Disruption
     */
    displayOnBoard?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V3Disruption
     */
    displayStatus?: boolean;
}

/**
 * 
 * @export
 * @interface V3DisruptionDirection
 */
export interface V3DisruptionDirection {
    /**
     * Route and direction of travel combination identifier
     * @type {number}
     * @memberof V3DisruptionDirection
     */
    routeDirectionId?: number;
    /**
     * Direction of travel identifier
     * @type {number}
     * @memberof V3DisruptionDirection
     */
    directionId?: number;
    /**
     * Name of direction of travel
     * @type {string}
     * @memberof V3DisruptionDirection
     */
    directionName?: string;
    /**
     * Time of service to which disruption applies, in 24 hour clock format (HH:MM:SS) AEDT/AEST; returns null if disruption applies to multiple (or no) services
     * @type {string}
     * @memberof V3DisruptionDirection
     */
    serviceTime?: string;
}

/**
 * 
 * @export
 * @interface V3DisruptionMode
 */
export interface V3DisruptionMode {
    /**
     * Name of disruption mode
     * @type {string}
     * @memberof V3DisruptionMode
     */
    disruptionModeName?: string;
    /**
     * Disruption mode identifier
     * @type {number}
     * @memberof V3DisruptionMode
     */
    disruptionMode?: number;
}

/**
 * 
 * @export
 * @interface V3DisruptionModesResponse
 */
export interface V3DisruptionModesResponse {
    /**
     * Transport mode identifiers
     * @type {Array<V3DisruptionMode>}
     * @memberof V3DisruptionModesResponse
     */
    disruptionModes?: Array<V3DisruptionMode>;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3DisruptionModesResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3DisruptionResponse
 */
export interface V3DisruptionResponse {
    /**
     * Disruption information applicable to relevant routes or stops
     * @type {V3Disruption}
     * @memberof V3DisruptionResponse
     */
    disruption?: V3Disruption;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3DisruptionResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3DisruptionRoute
 */
export interface V3DisruptionRoute {
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3DisruptionRoute
     */
    routeType?: number;
    /**
     * Route identifier
     * @type {number}
     * @memberof V3DisruptionRoute
     */
    routeId?: number;
    /**
     * Name of route
     * @type {string}
     * @memberof V3DisruptionRoute
     */
    routeName?: string;
    /**
     * Route number presented to public (i.e. not route_id)
     * @type {string}
     * @memberof V3DisruptionRoute
     */
    routeNumber?: string;
    /**
     * GTFS Identifer of the route
     * @type {string}
     * @memberof V3DisruptionRoute
     */
    routeGtfsId?: string;
    /**
     * Direction of travel relevant to a disruption (if applicable)
     * @type {V3DisruptionDirection}
     * @memberof V3DisruptionRoute
     */
    direction?: V3DisruptionDirection;
}

/**
 * 
 * @export
 * @interface V3DisruptionStop
 */
export interface V3DisruptionStop {
    /**
     * 
     * @type {number}
     * @memberof V3DisruptionStop
     */
    stopId?: number;
    /**
     * 
     * @type {string}
     * @memberof V3DisruptionStop
     */
    stopName?: string;
}

/**
 * 
 * @export
 * @interface V3Disruptions
 */
export interface V3Disruptions {
    /**
     * Subset of disruption information applicable to multiple route_types
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    general?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to metropolitan train
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    metroTrain?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to metropolitan tram
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    metroTram?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to metropolitan bus
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    metroBus?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to V/Line train
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    regionalTrain?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to V/Line coach
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    regionalCoach?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to regional bus
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    regionalBus?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to school bus
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    schoolBus?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to telebus services
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    telebus?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to night bus
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    nightBus?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to ferry
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    ferry?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to interstate train
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    interstateTrain?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to skybus
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    skybus?: Array<V3Disruption>;
    /**
     * Subset of disruption information applicable to taxi
     * @type {Array<V3Disruption>}
     * @memberof V3Disruptions
     */
    taxi?: Array<V3Disruption>;
}

/**
 * 
 * @export
 * @interface V3DisruptionsResponse
 */
export interface V3DisruptionsResponse {
    /**
     * Disruption information applicable to relevant routes or stops
     * @type {V3Disruptions}
     * @memberof V3DisruptionsResponse
     */
    disruptions?: V3Disruptions;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3DisruptionsResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3DynamoDbTimetable
 */
export interface V3DynamoDbTimetable {
    /**
     * Name of corresponding table in DynamoDB.
     * @type {string}
     * @memberof V3DynamoDbTimetable
     */
    tableName?: string;
    /**
     * Parser verison
     * @type {number}
     * @memberof V3DynamoDbTimetable
     */
    parserVersion?: number;
    /**
     * Diva Mapping Version used to load Parser into DynamoDB
     * @type {string}
     * @memberof V3DynamoDbTimetable
     */
    parserMappingVersion?: string;
    /**
     * PT version
     * @type {number}
     * @memberof V3DynamoDbTimetable
     */
    ptVersion?: number;
    /**
     * Diva Mapping Version used to load PT into DynamoDB
     * @type {string}
     * @memberof V3DynamoDbTimetable
     */
    ptMappingVersion?: string;
    /**
     * A.k.a. Transport Mode (e.g. Train, Tram, Bus, V/Line, Nightrider)
     * @type {number}
     * @memberof V3DynamoDbTimetable
     */
    transportType?: V3DynamoDbTimetable.TransportTypeEnum;
    /**
     * Formated date string of applicable date
     * @type {string}
     * @memberof V3DynamoDbTimetable
     */
    applicableLocalDate?: string;
    /**
     * True if the named table has been created in DynamoDB (i.e. at least one departure record has been loaded),  or false if there are no records for this date and transport type.
     * @type {boolean}
     * @memberof V3DynamoDbTimetable
     */
    exists?: boolean;
}

/**
 * @export
 * @namespace V3DynamoDbTimetable
 */
export namespace V3DynamoDbTimetable {
    /**
     * @export
     * @enum {string}
     */
    export enum TransportTypeEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_3 = <any> 3,
        NUMBER_4 = <any> 4
    }
}

/**
 * 
 * @export
 * @interface V3DynamoDbTimetablesReponse
 */
export interface V3DynamoDbTimetablesReponse {
    /**
     * 
     * @type {Array<V3DynamoDbTimetable>}
     * @memberof V3DynamoDbTimetablesReponse
     */
    timetables?: Array<V3DynamoDbTimetable>;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3DynamoDbTimetablesReponse
     */
    status?: V3Status;
}

/**
 * An error response
 * @export
 * @interface V3ErrorResponse
 */
export interface V3ErrorResponse {
    /**
     * Error message
     * @type {string}
     * @memberof V3ErrorResponse
     */
    message?: string;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3ErrorResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3FareEstimateResponse
 */
export interface V3FareEstimateResponse {
    /**
     * 
     * @type {V3FareEstimateResultStatus}
     * @memberof V3FareEstimateResponse
     */
    fareEstimateResultStatus?: V3FareEstimateResultStatus;
    /**
     * 
     * @type {V3FareEstimateResult}
     * @memberof V3FareEstimateResponse
     */
    fareEstimateResult?: V3FareEstimateResult;
}

/**
 * 
 * @export
 * @interface V3FareEstimateResult
 */
export interface V3FareEstimateResult {
    /**
     * 
     * @type {boolean}
     * @memberof V3FareEstimateResult
     */
    isEarlyBird?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V3FareEstimateResult
     */
    isJourneyInFreeTramZone?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V3FareEstimateResult
     */
    isThisWeekendJourney?: boolean;
    /**
     * 
     * @type {V3ZoneInfo}
     * @memberof V3FareEstimateResult
     */
    zoneInfo?: V3ZoneInfo;
    /**
     * 
     * @type {Array<V3PassengerFare>}
     * @memberof V3FareEstimateResult
     */
    passengerFares?: Array<V3PassengerFare>;
}

/**
 * 
 * @export
 * @interface V3FareEstimateResultStatus
 */
export interface V3FareEstimateResultStatus {
    /**
     * 
     * @type {number}
     * @memberof V3FareEstimateResultStatus
     */
    statusCode?: number;
    /**
     * 
     * @type {string}
     * @memberof V3FareEstimateResultStatus
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface V3GenerateDivaMappingResponse
 */
export interface V3GenerateDivaMappingResponse {
    /**
     * 
     * @type {string}
     * @memberof V3GenerateDivaMappingResponse
     */
    mappingVersion?: string;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3GenerateDivaMappingResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3Outlet
 */
export interface V3Outlet {
    /**
     * The SLID / SPID
     * @type {string}
     * @memberof V3Outlet
     */
    outletSlidSpid?: string;
    /**
     * The location name of the outlet
     * @type {string}
     * @memberof V3Outlet
     */
    outletName?: string;
    /**
     * The business name of the outlet
     * @type {string}
     * @memberof V3Outlet
     */
    outletBusiness?: string;
    /**
     * Geographic coordinate of latitude at outlet
     * @type {number}
     * @memberof V3Outlet
     */
    outletLatitude?: number;
    /**
     * Geographic coordinate of longitude at outlet
     * @type {number}
     * @memberof V3Outlet
     */
    outletLongitude?: number;
    /**
     * The city/municipality the outlet is in
     * @type {string}
     * @memberof V3Outlet
     */
    outletSuburb?: string;
    /**
     * The postcode for the outlet
     * @type {number}
     * @memberof V3Outlet
     */
    outletPostcode?: number;
    /**
     * The business hours on Monday
     * @type {string}
     * @memberof V3Outlet
     */
    outletBusinessHourMon?: string;
    /**
     * The business hours on Tuesday
     * @type {string}
     * @memberof V3Outlet
     */
    outletBusinessHourTue?: string;
    /**
     * The business hours on Wednesday
     * @type {string}
     * @memberof V3Outlet
     */
    outletBusinessHourWed?: string;
    /**
     * The business hours on Thursday
     * @type {string}
     * @memberof V3Outlet
     */
    outletBusinessHourThur?: string;
    /**
     * The business hours on Friday
     * @type {string}
     * @memberof V3Outlet
     */
    outletBusinessHourFri?: string;
    /**
     * The business hours on Saturday
     * @type {string}
     * @memberof V3Outlet
     */
    outletBusinessHourSat?: string;
    /**
     * The business hours on Sunday
     * @type {string}
     * @memberof V3Outlet
     */
    outletBusinessHourSun?: string;
    /**
     * Any additional notes for the outlet such as 'Buy pre-loaded myki cards only'. May be null/empty.
     * @type {string}
     * @memberof V3Outlet
     */
    outletNotes?: string;
}

/**
 * 
 * @export
 * @interface V3OutletGeolocation
 */
export interface V3OutletGeolocation {
    /**
     * Distance of outlet from input location (in metres); returns 0 if no location is input
     * @type {number}
     * @memberof V3OutletGeolocation
     */
    outletDistance?: number;
    /**
     * The SLID / SPID
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletSlidSpid?: string;
    /**
     * The location name of the outlet
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletName?: string;
    /**
     * The business name of the outlet
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletBusiness?: string;
    /**
     * Geographic coordinate of latitude at outlet
     * @type {number}
     * @memberof V3OutletGeolocation
     */
    outletLatitude?: number;
    /**
     * Geographic coordinate of longitude at outlet
     * @type {number}
     * @memberof V3OutletGeolocation
     */
    outletLongitude?: number;
    /**
     * The city/municipality the outlet is in
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletSuburb?: string;
    /**
     * The postcode for the outlet
     * @type {number}
     * @memberof V3OutletGeolocation
     */
    outletPostcode?: number;
    /**
     * The business hours on Monday
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletBusinessHourMon?: string;
    /**
     * The business hours on Tuesday
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletBusinessHourTue?: string;
    /**
     * The business hours on Wednesday
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletBusinessHourWed?: string;
    /**
     * The business hours on Thursday
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletBusinessHourThur?: string;
    /**
     * The business hours on Friday
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletBusinessHourFri?: string;
    /**
     * The business hours on Saturday
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletBusinessHourSat?: string;
    /**
     * The business hours on Sunday
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletBusinessHourSun?: string;
    /**
     * Any additional notes for the outlet such as 'Buy pre-loaded myki cards only'. May be null/empty.
     * @type {string}
     * @memberof V3OutletGeolocation
     */
    outletNotes?: string;
}

/**
 * 
 * @export
 * @interface V3OutletGeolocationParameters
 */
export interface V3OutletGeolocationParameters {
    /**
     * Filter by maximum distance (in metres) from location specified via latitude and longitude parameters (default = 300)
     * @type {number}
     * @memberof V3OutletGeolocationParameters
     */
    maxDistance?: number;
    /**
     * Maximum number of results returned (default = 30)
     * @type {number}
     * @memberof V3OutletGeolocationParameters
     */
    maxResults?: number;
}

/**
 * 
 * @export
 * @interface V3OutletGeolocationResponse
 */
export interface V3OutletGeolocationResponse {
    /**
     * myki ticket outlets
     * @type {Array<V3OutletGeolocation>}
     * @memberof V3OutletGeolocationResponse
     */
    outlets?: Array<V3OutletGeolocation>;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3OutletGeolocationResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3OutletParameters
 */
export interface V3OutletParameters {
    /**
     * Maximum number of results returned (default = 30)
     * @type {number}
     * @memberof V3OutletParameters
     */
    maxResults?: number;
}

/**
 * 
 * @export
 * @interface V3OutletResponse
 */
export interface V3OutletResponse {
    /**
     * myki ticket outlets
     * @type {Array<V3Outlet>}
     * @memberof V3OutletResponse
     */
    outlets?: Array<V3Outlet>;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3OutletResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3PassengerFare
 */
export interface V3PassengerFare {
    /**
     * 
     * @type {string}
     * @memberof V3PassengerFare
     */
    passengerType?: string;
    /**
     * 
     * @type {number}
     * @memberof V3PassengerFare
     */
    fare2HourPeak?: number;
    /**
     * 
     * @type {number}
     * @memberof V3PassengerFare
     */
    fare2HourOffPeak?: number;
    /**
     * 
     * @type {number}
     * @memberof V3PassengerFare
     */
    fareDailyPeak?: number;
    /**
     * 
     * @type {number}
     * @memberof V3PassengerFare
     */
    fareDailyOffPeak?: number;
    /**
     * 
     * @type {number}
     * @memberof V3PassengerFare
     */
    pass7Days?: number;
    /**
     * 
     * @type {number}
     * @memberof V3PassengerFare
     */
    pass28To69DayPerDay?: number;
    /**
     * 
     * @type {number}
     * @memberof V3PassengerFare
     */
    pass70PlusDayPerDay?: number;
    /**
     * 
     * @type {number}
     * @memberof V3PassengerFare
     */
    weekendCap?: number;
    /**
     * 
     * @type {number}
     * @memberof V3PassengerFare
     */
    holidayCap?: number;
}

/**
 * 
 * @export
 * @interface V3PatternDeparture
 */
export interface V3PatternDeparture {
    /**
     * The stops to be skipped following the current departure in order.
     * @type {Array<V3StopModel>}
     * @memberof V3PatternDeparture
     */
    skippedStops?: Array<V3StopModel>;
    /**
     * Stop identifier
     * @type {number}
     * @memberof V3PatternDeparture
     */
    stopId?: number;
    /**
     * Route identifier
     * @type {number}
     * @memberof V3PatternDeparture
     */
    routeId?: number;
    /**
     * Numeric trip/service run identifier. Defaults to -1 when run identifier is Alphanumeric
     * @type {number}
     * @memberof V3PatternDeparture
     */
    runId?: number;
    /**
     * Alphanumeric trip/service run identifier
     * @type {string}
     * @memberof V3PatternDeparture
     */
    runRef?: string;
    /**
     * Direction of travel identifier
     * @type {number}
     * @memberof V3PatternDeparture
     */
    directionId?: number;
    /**
     * Disruption information identifier(s)
     * @type {Array<number>}
     * @memberof V3PatternDeparture
     */
    disruptionIds?: Array<number>;
    /**
     * Scheduled (i.e. timetabled) departure time and date in ISO 8601 UTC format
     * @type {Date}
     * @memberof V3PatternDeparture
     */
    scheduledDepartureUtc?: Date;
    /**
     * Real-time estimate of departure time and date in ISO 8601 UTC format
     * @type {Date}
     * @memberof V3PatternDeparture
     */
    estimatedDepartureUtc?: Date;
    /**
     * Indicates if the metropolitan train service is at the platform at the time of query; returns false for other modes
     * @type {boolean}
     * @memberof V3PatternDeparture
     */
    atPlatform?: boolean;
    /**
     * Platform number at stop (metropolitan train only; returns null for other modes)
     * @type {string}
     * @memberof V3PatternDeparture
     */
    platformNumber?: string;
    /**
     * Flag indicating special condition for run (e.g. RR Reservations Required, GC Guaranteed Connection, DOO Drop Off Only, PUO Pick Up Only, MO Mondays only, TU Tuesdays only, WE Wednesdays only, TH Thursdays only, FR Fridays only, SS School days only; ignore E flag)
     * @type {string}
     * @memberof V3PatternDeparture
     */
    flags?: string;
    /**
     * Chronological sequence for the departures in a run. Order ascendingly by this field to get chronological order (earliest first) of departures with the same run_ref. NOTE, this field is not always N+1 or N-1 of the previous or following departure. e.g 100, 200, 250, 300 instead of 1, 2, 3, 4
     * @type {number}
     * @memberof V3PatternDeparture
     */
    departureSequence?: number;
}

/**
 * 
 * @export
 * @interface V3ResultOutlet
 */
export interface V3ResultOutlet {
    /**
     * Distance of outlet from input location (in metres); returns 0 if no location is input
     * @type {number}
     * @memberof V3ResultOutlet
     */
    outletDistance?: number;
    /**
     * The SLID / SPID
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletSlidSpid?: string;
    /**
     * The location name of the outlet
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletName?: string;
    /**
     * The business name of the outlet
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletBusiness?: string;
    /**
     * Geographic coordinate of latitude at outlet
     * @type {number}
     * @memberof V3ResultOutlet
     */
    outletLatitude?: number;
    /**
     * Geographic coordinate of longitude at outlet
     * @type {number}
     * @memberof V3ResultOutlet
     */
    outletLongitude?: number;
    /**
     * The city/municipality the outlet is in
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletSuburb?: string;
    /**
     * The postcode for the outlet
     * @type {number}
     * @memberof V3ResultOutlet
     */
    outletPostcode?: number;
    /**
     * The business hours on Monday
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletBusinessHourMon?: string;
    /**
     * The business hours on Tuesday
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletBusinessHourTue?: string;
    /**
     * The business hours on Wednesday
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletBusinessHourWed?: string;
    /**
     * The business hours on Thursday
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletBusinessHourThur?: string;
    /**
     * The business hours on Friday
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletBusinessHourFri?: string;
    /**
     * The business hours on Saturday
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletBusinessHourSat?: string;
    /**
     * The business hours on Sunday
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletBusinessHourSun?: string;
    /**
     * Any additional notes for the outlet such as 'Buy pre-loaded myki cards only'. May be null/empty.
     * @type {string}
     * @memberof V3ResultOutlet
     */
    outletNotes?: string;
}

/**
 * 
 * @export
 * @interface V3ResultRoute
 */
export interface V3ResultRoute {
    /**
     * Name of route
     * @type {string}
     * @memberof V3ResultRoute
     */
    routeName?: string;
    /**
     * Route number presented to public (nb. not route_id)
     * @type {string}
     * @memberof V3ResultRoute
     */
    routeNumber?: string;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3ResultRoute
     */
    routeType?: number;
    /**
     * Route identifier
     * @type {number}
     * @memberof V3ResultRoute
     */
    routeId?: number;
    /**
     * GTFS Identifer of the route
     * @type {string}
     * @memberof V3ResultRoute
     */
    routeGtfsId?: string;
    /**
     * Service status for the route (indicates disruptions)
     * @type {V3RouteServiceStatus}
     * @memberof V3ResultRoute
     */
    routeServiceStatus?: V3RouteServiceStatus;
}

/**
 * 
 * @export
 * @interface V3ResultStop
 */
export interface V3ResultStop {
    /**
     * Distance of stop from input location (in metres); returns 0 if no location is input
     * @type {number}
     * @memberof V3ResultStop
     */
    stopDistance?: number;
    /**
     * suburb of stop
     * @type {string}
     * @memberof V3ResultStop
     */
    stopSuburb?: string;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3ResultStop
     */
    routeType?: number;
    /**
     * List of routes travelling through the stop
     * @type {Array<V3ResultRoute>}
     * @memberof V3ResultStop
     */
    routes?: Array<V3ResultRoute>;
    /**
     * Geographic coordinate of latitude at stop
     * @type {number}
     * @memberof V3ResultStop
     */
    stopLatitude?: number;
    /**
     * Geographic coordinate of longitude at stop
     * @type {number}
     * @memberof V3ResultStop
     */
    stopLongitude?: number;
    /**
     * Sequence of the stop on the route/run; return 0 when route_id or run_id not specified. Order ascendingly by this field (when non zero) to get physical order (earliest first) of stops on the route_id/run_id.
     * @type {number}
     * @memberof V3ResultStop
     */
    stopSequence?: number;
    /**
     * Stop identifier
     * @type {number}
     * @memberof V3ResultStop
     */
    stopId?: number;
    /**
     * Name of stop
     * @type {string}
     * @memberof V3ResultStop
     */
    stopName?: string;
    /**
     * Landmark in proximity of stop
     * @type {string}
     * @memberof V3ResultStop
     */
    stopLandmark?: string;
}

/**
 * 
 * @export
 * @interface V3RouteDeparturesSpecificParameters
 */
export interface V3RouteDeparturesSpecificParameters {
    /**
     * DEPRECATED - use `scheduled_timetables` instead
     * @type {boolean}
     * @memberof V3RouteDeparturesSpecificParameters
     */
    trainScheduledTimetables?: boolean;
    /**
     * When set to true, all timetable information returned by Chronos will be sourced from the scheduled timetables,  while when set to false (default state), the operational timetables will be used where available.
     * @type {boolean}
     * @memberof V3RouteDeparturesSpecificParameters
     */
    scheduledTimetables?: boolean;
    /**
     * Filter by the date and time of the request (ISO 8601 UTC format) (default = current date and time)
     * @type {Date}
     * @memberof V3RouteDeparturesSpecificParameters
     */
    dateUtc?: Date;
    /**
     * Maximum number of results returned
     * @type {number}
     * @memberof V3RouteDeparturesSpecificParameters
     */
    maxResults?: number;
    /**
     * Indicates if cancelled services (if they exist) are returned (default = false) - metropolitan train only
     * @type {boolean}
     * @memberof V3RouteDeparturesSpecificParameters
     */
    includeCancelled?: boolean;
    /**
     * Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default = false). Requires max_results &gt; 0.
     * @type {boolean}
     * @memberof V3RouteDeparturesSpecificParameters
     */
    lookBackwards?: boolean;
    /**
     * List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
     * @type {Array<string>}
     * @memberof V3RouteDeparturesSpecificParameters
     */
    expand?: Array<V3RouteDeparturesSpecificParameters.ExpandEnum>;
    /**
     * Indicates if the route geopath should be returned
     * @type {boolean}
     * @memberof V3RouteDeparturesSpecificParameters
     */
    includeGeopath?: boolean;
}

/**
 * @export
 * @namespace V3RouteDeparturesSpecificParameters
 */
export namespace V3RouteDeparturesSpecificParameters {
    /**
     * @export
     * @enum {string}
     */
    export enum ExpandEnum {
        All = <any> 'All',
        Stop = <any> 'Stop',
        Route = <any> 'Route',
        Run = <any> 'Run',
        Direction = <any> 'Direction',
        Disruption = <any> 'Disruption',
        VehicleDescriptor = <any> 'VehicleDescriptor',
        VehiclePosition = <any> 'VehiclePosition',
        None = <any> 'None'
    }
}

/**
 * 
 * @export
 * @interface V3RouteResponse
 */
export interface V3RouteResponse {
    /**
     * Train lines, tram routes, bus routes, regional coach routes, Night Bus routes
     * @type {V3RouteWithStatus}
     * @memberof V3RouteResponse
     */
    route?: V3RouteWithStatus;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3RouteResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3RouteServiceStatus
 */
export interface V3RouteServiceStatus {
    /**
     * 
     * @type {string}
     * @memberof V3RouteServiceStatus
     */
    description?: string;
    /**
     * 
     * @type {Date}
     * @memberof V3RouteServiceStatus
     */
    timestamp?: Date;
}

/**
 * 
 * @export
 * @interface V3RouteType
 */
export interface V3RouteType {
    /**
     * Name of transport mode
     * @type {string}
     * @memberof V3RouteType
     */
    routeTypeName?: string;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3RouteType
     */
    routeType?: number;
}

/**
 * 
 * @export
 * @interface V3RouteTypesResponse
 */
export interface V3RouteTypesResponse {
    /**
     * Transport mode identifiers
     * @type {Array<V3RouteType>}
     * @memberof V3RouteTypesResponse
     */
    routeTypes?: Array<V3RouteType>;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3RouteTypesResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3RouteWithStatus
 */
export interface V3RouteWithStatus {
    /**
     * Service status for the route (indicates disruptions)
     * @type {V3RouteServiceStatus}
     * @memberof V3RouteWithStatus
     */
    routeServiceStatus?: V3RouteServiceStatus;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3RouteWithStatus
     */
    routeType?: number;
    /**
     * Route identifier
     * @type {number}
     * @memberof V3RouteWithStatus
     */
    routeId?: number;
    /**
     * Name of route
     * @type {string}
     * @memberof V3RouteWithStatus
     */
    routeName?: string;
    /**
     * Route number presented to public (nb. not route_id)
     * @type {string}
     * @memberof V3RouteWithStatus
     */
    routeNumber?: string;
    /**
     * GTFS Identifer of the route
     * @type {string}
     * @memberof V3RouteWithStatus
     */
    routeGtfsId?: string;
    /**
     * GeoPath of the route
     * @type {Array<any>}
     * @memberof V3RouteWithStatus
     */
    geopath?: Array<any>;
}

/**
 * 
 * @export
 * @interface V3Run
 */
export interface V3Run {
    /**
     * Numeric trip/service run identifier. Defaults to -1 when run identifier is Alphanumeric
     * @type {number}
     * @memberof V3Run
     */
    runId?: number;
    /**
     * Alphanumeric trip/service run identifier
     * @type {string}
     * @memberof V3Run
     */
    runRef?: string;
    /**
     * Route identifier
     * @type {number}
     * @memberof V3Run
     */
    routeId?: number;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3Run
     */
    routeType?: number;
    /**
     * stop_id of final stop of run
     * @type {number}
     * @memberof V3Run
     */
    finalStopId?: number;
    /**
     * Name of destination of run
     * @type {string}
     * @memberof V3Run
     */
    destinationName?: string;
    /**
     * Status of metropolitan train run; returns \"scheduled\" for other modes
     * @type {string}
     * @memberof V3Run
     */
    status?: string;
    /**
     * Direction of travel identifier
     * @type {number}
     * @memberof V3Run
     */
    directionId?: number;
    /**
     * Chronological sequence of the trip/service run on the route in direction. Order ascendingly by this field to get chronological order (earliest first) of runs with the same route_id and direction_id.
     * @type {number}
     * @memberof V3Run
     */
    runSequence?: number;
    /**
     * The number of remaining skipped/express stations for the run/service from a stop
     * @type {number}
     * @memberof V3Run
     */
    expressStopCount?: number;
    /**
     * Position of the trip/service run. Available for some Bus, Nightrider and Train runs. May be null.
     * @type {V3VehiclePosition}
     * @memberof V3Run
     */
    vehiclePosition?: V3VehiclePosition;
    /**
     * Descriptor of the trip/service run. Only available for some runs. May be null.
     * @type {V3VehicleDescriptor}
     * @memberof V3Run
     */
    vehicleDescriptor?: V3VehicleDescriptor;
    /**
     * Geopath of the route
     * @type {Array<any>}
     * @memberof V3Run
     */
    geopath?: Array<any>;
}

/**
 * 
 * @export
 * @interface V3RunResponse
 */
export interface V3RunResponse {
    /**
     * Individual trip/service of a route
     * @type {V3Run}
     * @memberof V3RunResponse
     */
    run?: V3Run;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3RunResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3RunsResponse
 */
export interface V3RunsResponse {
    /**
     * Individual trips/services of a route
     * @type {Array<V3Run>}
     * @memberof V3RunsResponse
     */
    runs?: Array<V3Run>;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3RunsResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3SearchParameters
 */
export interface V3SearchParameters {
    /**
     * Filter by route_type; values returned via RouteTypes API (note: stops and routes are ordered by route_types specified)
     * @type {Array<number>}
     * @memberof V3SearchParameters
     */
    routeTypes?: Array<V3SearchParameters.RouteTypesEnum>;
    /**
     * Filter by geographic coordinate of latitude
     * @type {number}
     * @memberof V3SearchParameters
     */
    latitude?: number;
    /**
     * Filter by geographic coordinate of longitude
     * @type {number}
     * @memberof V3SearchParameters
     */
    longitude?: number;
    /**
     * Filter by maximum distance (in metres) from location specified via latitude and longitude parameters
     * @type {number}
     * @memberof V3SearchParameters
     */
    maxDistance?: number;
    /**
     * Placeholder for future development; currently unavailable
     * @type {boolean}
     * @memberof V3SearchParameters
     */
    includeAddresses?: boolean;
    /**
     * Indicates if outlets will be returned in response (default = true)
     * @type {boolean}
     * @memberof V3SearchParameters
     */
    includeOutlets?: boolean;
    /**
     * Indicates whether to find stops by suburbs in the search term (default = true)
     * @type {boolean}
     * @memberof V3SearchParameters
     */
    matchStopBySuburb?: boolean;
    /**
     * Indicates whether to find routes by suburbs in the search term (default = true)
     * @type {boolean}
     * @memberof V3SearchParameters
     */
    matchRouteBySuburb?: boolean;
    /**
     * Indicates whether to search for stops according to a metlink stop ID (default = false)
     * @type {boolean}
     * @memberof V3SearchParameters
     */
    matchStopByGtfsStopId?: boolean;
}

/**
 * @export
 * @namespace V3SearchParameters
 */
export namespace V3SearchParameters {
    /**
     * @export
     * @enum {string}
     */
    export enum RouteTypesEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4'
    }
}

/**
 * 
 * @export
 * @interface V3SearchResult
 */
export interface V3SearchResult {
    /**
     * Train stations, tram stops, bus stops, regional coach stops or Night Bus stops
     * @type {Array<V3ResultStop>}
     * @memberof V3SearchResult
     */
    stops?: Array<V3ResultStop>;
    /**
     * Train lines, tram routes, bus routes, regional coach routes, Night Bus routes
     * @type {Array<V3ResultRoute>}
     * @memberof V3SearchResult
     */
    routes?: Array<V3ResultRoute>;
    /**
     * myki ticket outlets
     * @type {Array<V3ResultOutlet>}
     * @memberof V3SearchResult
     */
    outlets?: Array<V3ResultOutlet>;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3SearchResult
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3SiriDirectionRefsDictionary
 */
export interface V3SiriDirectionRefsDictionary {
    /**
     * 
     * @type {{ [key: string]: V3SiriStopsRefsDictionary; }}
     * @memberof V3SiriDirectionRefsDictionary
     */
    directionRefs?: { [key: string]: V3SiriStopsRefsDictionary; };
}

/**
 * 
 * @export
 * @interface V3SiriDownstreamSubscription
 */
export interface V3SiriDownstreamSubscription {
    /**
     * 
     * @type {string}
     * @memberof V3SiriDownstreamSubscription
     */
    subscriberRef?: string;
    /**
     * 
     * @type {string}
     * @memberof V3SiriDownstreamSubscription
     */
    subscriptionRef?: string;
    /**
     * 
     * @type {number}
     * @memberof V3SiriDownstreamSubscription
     */
    messageType?: V3SiriDownstreamSubscription.MessageTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof V3SiriDownstreamSubscription
     */
    siriFormat?: V3SiriDownstreamSubscription.SiriFormatEnum;
    /**
     * 
     * @type {string}
     * @memberof V3SiriDownstreamSubscription
     */
    siriVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof V3SiriDownstreamSubscription
     */
    consumerAddress?: string;
    /**
     * 
     * @type {Date}
     * @memberof V3SiriDownstreamSubscription
     */
    initialTerminationTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V3SiriDownstreamSubscription
     */
    validityPeriodStart?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V3SiriDownstreamSubscription
     */
    validityPeriodEnd?: Date;
    /**
     * 
     * @type {string}
     * @memberof V3SiriDownstreamSubscription
     */
    previewInterval?: string;
    /**
     * 
     * @type {Array<V3SiriDownstreamSubscriptionTopic>}
     * @memberof V3SiriDownstreamSubscription
     */
    topics?: Array<V3SiriDownstreamSubscriptionTopic>;
}

/**
 * @export
 * @namespace V3SiriDownstreamSubscription
 */
export namespace V3SiriDownstreamSubscription {
    /**
     * @export
     * @enum {string}
     */
    export enum MessageTypeEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SiriFormatEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}

/**
 * 
 * @export
 * @interface V3SiriDownstreamSubscriptionDeleteRequest
 */
export interface V3SiriDownstreamSubscriptionDeleteRequest {
    /**
     * Siri Subscriber Ref
     * @type {string}
     * @memberof V3SiriDownstreamSubscriptionDeleteRequest
     */
    subscriberRef: string;
    /**
     * Siri Subscription Reference(s) - Unique to a Subscriber Ref.  If `null`, then all subscriptions will be terminated for the referenced Subscriber.
     * @type {Array<string>}
     * @memberof V3SiriDownstreamSubscriptionDeleteRequest
     */
    subscriptionRef?: Array<string>;
}

/**
 * 
 * @export
 * @interface V3SiriDownstreamSubscriptionResponse
 */
export interface V3SiriDownstreamSubscriptionResponse {
    /**
     * The Data Horizon of Chronos
     * @type {Date}
     * @memberof V3SiriDownstreamSubscriptionResponse
     */
    validUntil?: Date;
}

/**
 * 
 * @export
 * @interface V3SiriDownstreamSubscriptionTopic
 */
export interface V3SiriDownstreamSubscriptionTopic {
    /**
     * 
     * @type {string}
     * @memberof V3SiriDownstreamSubscriptionTopic
     */
    lineRef?: string;
    /**
     * 
     * @type {number}
     * @memberof V3SiriDownstreamSubscriptionTopic
     */
    directionRef?: V3SiriDownstreamSubscriptionTopic.DirectionRefEnum;
    /**
     * 
     * @type {number}
     * @memberof V3SiriDownstreamSubscriptionTopic
     */
    routeType?: V3SiriDownstreamSubscriptionTopic.RouteTypeEnum;
}

/**
 * @export
 * @namespace V3SiriDownstreamSubscriptionTopic
 */
export namespace V3SiriDownstreamSubscriptionTopic {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionRefEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_5 = <any> 5,
        NUMBER_10 = <any> 10,
        NUMBER_16 = <any> 16,
        NUMBER_32 = <any> 32,
        NUMBER_65 = <any> 65,
        NUMBER_130 = <any> 130
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RouteTypeEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_3 = <any> 3,
        NUMBER_4 = <any> 4
    }
}

/**
 * 
 * @export
 * @interface V3SiriEstimatedTimetableSubscriptionRequest
 */
export interface V3SiriEstimatedTimetableSubscriptionRequest {
    /**
     * Siri Preview Interval
     * @type {string}
     * @memberof V3SiriEstimatedTimetableSubscriptionRequest
     */
    previewInterval: string;
    /**
     * Siri Subscriber Ref
     * @type {string}
     * @memberof V3SiriEstimatedTimetableSubscriptionRequest
     */
    subscriberRef: string;
    /**
     * Siri Subscription Ref - Unique to a Subscriber Ref
     * @type {string}
     * @memberof V3SiriEstimatedTimetableSubscriptionRequest
     */
    subscriptionRef: string;
    /**
     * Siri Message Format 'xml' or 'json'
     * @type {number}
     * @memberof V3SiriEstimatedTimetableSubscriptionRequest
     */
    siriFormat: V3SiriEstimatedTimetableSubscriptionRequest.SiriFormatEnum;
    /**
     * Siri Message Version '1.3' or '2.0'
     * @type {string}
     * @memberof V3SiriEstimatedTimetableSubscriptionRequest
     */
    siriVersion: string;
    /**
     * Siri Consumer Address - Baseline and Updates will be sent to this address
     * @type {string}
     * @memberof V3SiriEstimatedTimetableSubscriptionRequest
     */
    consumerAddress: string;
    /**
     * Siri Initial Termination Time - Expiry of the subscription
     * @type {Date}
     * @memberof V3SiriEstimatedTimetableSubscriptionRequest
     */
    initialTerminationTime: Date;
    /**
     * 
     * @type {Array<V3SiriSubscriptionTopic>}
     * @memberof V3SiriEstimatedTimetableSubscriptionRequest
     */
    topics: Array<V3SiriSubscriptionTopic>;
}

/**
 * @export
 * @namespace V3SiriEstimatedTimetableSubscriptionRequest
 */
export namespace V3SiriEstimatedTimetableSubscriptionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SiriFormatEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}

/**
 * 
 * @export
 * @interface V3SiriLineRef
 */
export interface V3SiriLineRef {
    /**
     * Siri LineRef
     * @type {string}
     * @memberof V3SiriLineRef
     */
    lineRef: string;
    /**
     * Siri DirectionRef  (in, out, up, down, clockwise, counterclockwise, Inbound, Outbound)
     * @type {number}
     * @memberof V3SiriLineRef
     */
    directionRef?: V3SiriLineRef.DirectionRefEnum;
}

/**
 * @export
 * @namespace V3SiriLineRef
 */
export namespace V3SiriLineRef {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionRefEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_5 = <any> 5,
        NUMBER_10 = <any> 10,
        NUMBER_16 = <any> 16,
        NUMBER_32 = <any> 32,
        NUMBER_65 = <any> 65,
        NUMBER_130 = <any> 130
    }
}

/**
 * 
 * @export
 * @interface V3SiriLineRefDirectionRefStopPointRef
 */
export interface V3SiriLineRefDirectionRefStopPointRef {
    /**
     * Siri LineRef
     * @type {string}
     * @memberof V3SiriLineRefDirectionRefStopPointRef
     */
    lineRef: string;
    /**
     * Siri DirectionRef  (in, out, up, down, clockwise, counterclockwise, Inbound, Outbound)
     * @type {number}
     * @memberof V3SiriLineRefDirectionRefStopPointRef
     */
    directionRef: V3SiriLineRefDirectionRefStopPointRef.DirectionRefEnum;
    /**
     * Siri StopPointRef
     * @type {number}
     * @memberof V3SiriLineRefDirectionRefStopPointRef
     */
    stopPointRef: number;
}

/**
 * @export
 * @namespace V3SiriLineRefDirectionRefStopPointRef
 */
export namespace V3SiriLineRefDirectionRefStopPointRef {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionRefEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_5 = <any> 5,
        NUMBER_10 = <any> 10,
        NUMBER_16 = <any> 16,
        NUMBER_32 = <any> 32,
        NUMBER_65 = <any> 65,
        NUMBER_130 = <any> 130
    }
}

/**
 * 
 * @export
 * @interface V3SiriLineRefDirectionRefsDictionary
 */
export interface V3SiriLineRefDirectionRefsDictionary {
    /**
     * 
     * @type {{ [key: string]: Array<V3SiriReferenceDataDetail>; }}
     * @memberof V3SiriLineRefDirectionRefsDictionary
     */
    directionRefs?: { [key: string]: Array<V3SiriReferenceDataDetail>; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V3SiriLineRefDirectionRefsDictionary
     */
    unmatchedDirectionRefs?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface V3SiriLineRefMappingsResponse
 */
export interface V3SiriLineRefMappingsResponse {
    /**
     * 
     * @type {string}
     * @memberof V3SiriLineRefMappingsResponse
     */
    mappingVersion?: string;
    /**
     * 
     * @type {{ [key: string]: V3SiriLineRefDirectionRefsDictionary; }}
     * @memberof V3SiriLineRefMappingsResponse
     */
    lineRefs?: { [key: string]: V3SiriLineRefDirectionRefsDictionary; };
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3SiriLineRefMappingsResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3SiriLineRefsRequest
 */
export interface V3SiriLineRefsRequest {
    /**
     * 
     * @type {Array<V3SiriLineRef>}
     * @memberof V3SiriLineRefsRequest
     */
    lineRefs?: Array<V3SiriLineRef>;
    /**
     * DIVA mapping version generated by Chronos during a Parser or RealtimeBusConfig load
     * @type {string}
     * @memberof V3SiriLineRefsRequest
     */
    mappingVersion: string;
}

/**
 * 
 * @export
 * @interface V3SiriProductionTimetableSubscriptionRequest
 */
export interface V3SiriProductionTimetableSubscriptionRequest {
    /**
     * Siri Start Time of the Validity Period
     * @type {Date}
     * @memberof V3SiriProductionTimetableSubscriptionRequest
     */
    startTime: Date;
    /**
     * Siri End Time of the Validity Period
     * @type {Date}
     * @memberof V3SiriProductionTimetableSubscriptionRequest
     */
    endTime: Date;
    /**
     * Siri Subscriber Ref
     * @type {string}
     * @memberof V3SiriProductionTimetableSubscriptionRequest
     */
    subscriberRef: string;
    /**
     * Siri Subscription Ref - Unique to a Subscriber Ref
     * @type {string}
     * @memberof V3SiriProductionTimetableSubscriptionRequest
     */
    subscriptionRef: string;
    /**
     * Siri Message Format 'xml' or 'json'
     * @type {number}
     * @memberof V3SiriProductionTimetableSubscriptionRequest
     */
    siriFormat: V3SiriProductionTimetableSubscriptionRequest.SiriFormatEnum;
    /**
     * Siri Message Version '1.3' or '2.0'
     * @type {string}
     * @memberof V3SiriProductionTimetableSubscriptionRequest
     */
    siriVersion: string;
    /**
     * Siri Consumer Address - Baseline and Updates will be sent to this address
     * @type {string}
     * @memberof V3SiriProductionTimetableSubscriptionRequest
     */
    consumerAddress: string;
    /**
     * Siri Initial Termination Time - Expiry of the subscription
     * @type {Date}
     * @memberof V3SiriProductionTimetableSubscriptionRequest
     */
    initialTerminationTime: Date;
    /**
     * 
     * @type {Array<V3SiriSubscriptionTopic>}
     * @memberof V3SiriProductionTimetableSubscriptionRequest
     */
    topics: Array<V3SiriSubscriptionTopic>;
}

/**
 * @export
 * @namespace V3SiriProductionTimetableSubscriptionRequest
 */
export namespace V3SiriProductionTimetableSubscriptionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SiriFormatEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}

/**
 * 
 * @export
 * @interface V3SiriReferenceDataDetail
 */
export interface V3SiriReferenceDataDetail {
    /**
     * 
     * @type {number}
     * @memberof V3SiriReferenceDataDetail
     */
    routeId?: number;
    /**
     * Route number
     * @type {string}
     * @memberof V3SiriReferenceDataDetail
     */
    routeNumberShort?: string;
    /**
     * 
     * @type {number}
     * @memberof V3SiriReferenceDataDetail
     */
    directionId?: number;
    /**
     * Authority (Upstream SIRI provider) of a route and direction
     * @type {number}
     * @memberof V3SiriReferenceDataDetail
     */
    trackingSupplierId?: number;
    /**
     * 
     * @type {number}
     * @memberof V3SiriReferenceDataDetail
     */
    routeType?: number;
}

/**
 * 
 * @export
 * @interface V3SiriReferenceDataMappingsResponse
 */
export interface V3SiriReferenceDataMappingsResponse {
    /**
     * 
     * @type {string}
     * @memberof V3SiriReferenceDataMappingsResponse
     */
    mappingVersion?: string;
    /**
     * SIRI LineRef
     * @type {{ [key: string]: V3SiriDirectionRefsDictionary; }}
     * @memberof V3SiriReferenceDataMappingsResponse
     */
    lineRefs?: { [key: string]: V3SiriDirectionRefsDictionary; };
    /**
     * 
     * @type {{ [key: string]: V3StopPoint; }}
     * @memberof V3SiriReferenceDataMappingsResponse
     */
    stopPointRefs?: { [key: string]: V3StopPoint; };
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3SiriReferenceDataMappingsResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3SiriReferenceDataRequest
 */
export interface V3SiriReferenceDataRequest {
    /**
     * 
     * @type {Array<V3SiriLineRefDirectionRefStopPointRef>}
     * @memberof V3SiriReferenceDataRequest
     */
    lineRefs: Array<V3SiriLineRefDirectionRefStopPointRef>;
    /**
     * Siri StopPointRef
     * @type {Array<number>}
     * @memberof V3SiriReferenceDataRequest
     */
    stopPointRefs?: Array<number>;
    /**
     * Filter by the date and time of the request (ISO 8601 UTC format) (default = current date and time)
     * @type {Date}
     * @memberof V3SiriReferenceDataRequest
     */
    dateUtc?: Date;
    /**
     * DIVA mapping version generated by Chronos during a Parser or RealtimeBusConfig load
     * @type {string}
     * @memberof V3SiriReferenceDataRequest
     */
    mappingVersion: string;
}

/**
 * 
 * @export
 * @interface V3SiriStopsRefsDictionary
 */
export interface V3SiriStopsRefsDictionary {
    /**
     * 
     * @type {{ [key: string]: V3SiriReferenceDataDetail; }}
     * @memberof V3SiriStopsRefsDictionary
     */
    stopPointRefs?: { [key: string]: V3SiriReferenceDataDetail; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V3SiriStopsRefsDictionary
     */
    unmatchedStopPointRefs?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface V3SiriSubscriptionTopic
 */
export interface V3SiriSubscriptionTopic {
    /**
     * Siri LineRef
     * @type {string}
     * @memberof V3SiriSubscriptionTopic
     */
    lineRef: string;
    /**
     * Siri DirectionRef  (in, out, up, down, clockwise, counterclockwise, Inbound, Outbound)
     * @type {number}
     * @memberof V3SiriSubscriptionTopic
     */
    directionRef?: V3SiriSubscriptionTopic.DirectionRefEnum;
    /**
     * Route Type eg. 0 (Train) 1 (Tram) 2 (Bus) 3 (Vline) 4 (NightRider)
     * @type {number}
     * @memberof V3SiriSubscriptionTopic
     */
    routeType: V3SiriSubscriptionTopic.RouteTypeEnum;
}

/**
 * @export
 * @namespace V3SiriSubscriptionTopic
 */
export namespace V3SiriSubscriptionTopic {
    /**
     * @export
     * @enum {string}
     */
    export enum DirectionRefEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_5 = <any> 5,
        NUMBER_10 = <any> 10,
        NUMBER_16 = <any> 16,
        NUMBER_32 = <any> 32,
        NUMBER_65 = <any> 65,
        NUMBER_130 = <any> 130
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RouteTypeEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_3 = <any> 3,
        NUMBER_4 = <any> 4
    }
}

/**
 * 
 * @export
 * @interface V3Status
 */
export interface V3Status {
    /**
     * API Version number
     * @type {string}
     * @memberof V3Status
     */
    version?: string;
    /**
     * API system health status (0=offline, 1=online)
     * @type {number}
     * @memberof V3Status
     */
    health?: V3Status.HealthEnum;
}

/**
 * @export
 * @namespace V3Status
 */
export namespace V3Status {
    /**
     * @export
     * @enum {string}
     */
    export enum HealthEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}

/**
 * 
 * @export
 * @interface V3StopAccessibility
 */
export interface V3StopAccessibility {
    /**
     * Indicates if there is lighting at the stop
     * @type {boolean}
     * @memberof V3StopAccessibility
     */
    lighting?: boolean;
    /**
     * Indicates the platform number for xivic information (Platform 0 indicates general stop facilities)
     * @type {number}
     * @memberof V3StopAccessibility
     */
    platformNumber?: number;
    /**
     * Indicates if there is at least one audio customer information at the stop/platform
     * @type {boolean}
     * @memberof V3StopAccessibility
     */
    audioCustomerInformation?: boolean;
    /**
     * Indicates if there is at least one accessible escalator at the stop/platform that complies with the Disability Standards for Accessible Public Transport under the Disability Discrimination Act (1992)
     * @type {boolean}
     * @memberof V3StopAccessibility
     */
    escalator?: boolean;
    /**
     * Indicates if there is a hearing loop facility at the stop/platform
     * @type {boolean}
     * @memberof V3StopAccessibility
     */
    hearingLoop?: boolean;
    /**
     * Indicates if there is an elevator at the stop/platform
     * @type {boolean}
     * @memberof V3StopAccessibility
     */
    lift?: boolean;
    /**
     * Indicates if there are stairs available in the stop
     * @type {boolean}
     * @memberof V3StopAccessibility
     */
    stairs?: boolean;
    /**
     * Indicates if the stop is accessible
     * @type {boolean}
     * @memberof V3StopAccessibility
     */
    stopAccessible?: boolean;
    /**
     * Indicates if there are tactile tiles (also known as tactile ground surface indicators, or TGSIs) at the stop
     * @type {boolean}
     * @memberof V3StopAccessibility
     */
    tactileGroundSurfaceIndicator?: boolean;
    /**
     * Indicates if there is a general waiting area at the stop
     * @type {boolean}
     * @memberof V3StopAccessibility
     */
    waitingRoom?: boolean;
    /**
     * Facilities relating to the accessibility of the stop by wheelchair
     * @type {V3StopAccessibilityWheelchair}
     * @memberof V3StopAccessibility
     */
    wheelchair?: V3StopAccessibilityWheelchair;
}

/**
 * 
 * @export
 * @interface V3StopAccessibilityWheelchair
 */
export interface V3StopAccessibilityWheelchair {
    /**
     * 
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    accessibleRamp?: boolean;
    /**
     * Indicates if there is at least one accessible parking spot at the stop that complies with the Disability Standards for Accessible Public Transport under the Disability Discrimination Act (1992)
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    parking?: boolean;
    /**
     * Indicates if there is at least one accessible telephone at the stop/platform that complies with the Disability Standards for Accessible Public Transport under the Disability Discrimination Act (1992)
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    telephone?: boolean;
    /**
     * Indicates if there is at least one accessible toilet at the stop/platform that complies with the Disability Standards for Accessible Public Transport under the Disability Discrimination Act (1992)
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    toilet?: boolean;
    /**
     * Indicates if there is at least one low ticket counter at the stop that complies with the Disability Standards for Accessible Public Transport under the Disability Discrimination Act (1992)
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    lowTicketCounter?: boolean;
    /**
     * Indicates if there is a space for mobility device to board on or off a transport mode
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    manouvering?: boolean;
    /**
     * Indicates if there is a raised platform to board a train
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    raisedPlatform?: boolean;
    /**
     * Indicates if there are ramps (&lt;1:14) at the stop/platform
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    ramp?: boolean;
    /**
     * Indicates if there is a path beyond the stop which is accessible
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    secondaryPath?: boolean;
    /**
     * Indicates if there is shelter near the raised platform
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    raisedPlatformShelther?: boolean;
    /**
     * Indicates if there are ramps (&gt;1:14) at the stop/platform
     * @type {boolean}
     * @memberof V3StopAccessibilityWheelchair
     */
    steepRamp?: boolean;
}

/**
 * 
 * @export
 * @interface V3StopAmenityDetails
 */
export interface V3StopAmenityDetails {
    /**
     * Indicates if there is a public toilet at or near the stop
     * @type {boolean}
     * @memberof V3StopAmenityDetails
     */
    toilet?: boolean;
    /**
     * Indicates if there is a taxi rank at or near the stop
     * @type {boolean}
     * @memberof V3StopAmenityDetails
     */
    taxiRank?: boolean;
    /**
     * The number of free car parking spots at the stop
     * @type {string}
     * @memberof V3StopAmenityDetails
     */
    carParking?: string;
    /**
     * Indicates if there are CCTV (i.e. closed circuit television) cameras at the stop
     * @type {boolean}
     * @memberof V3StopAmenityDetails
     */
    cctv?: boolean;
}

/**
 * 
 * @export
 * @interface V3StopBasic
 */
export interface V3StopBasic {
    /**
     * 
     * @type {number}
     * @memberof V3StopBasic
     */
    stopId?: number;
    /**
     * 
     * @type {string}
     * @memberof V3StopBasic
     */
    stopName?: string;
}

/**
 * 
 * @export
 * @interface V3StopDepartureRequest
 */
export interface V3StopDepartureRequest {
    /**
     * Number identifying transport mode; values returned via RouteTypes API
     * @type {number}
     * @memberof V3StopDepartureRequest
     */
    routeType?: V3StopDepartureRequest.RouteTypeEnum;
    /**
     * Identifier of stop; values returned by Stops API
     * @type {number}
     * @memberof V3StopDepartureRequest
     */
    stopId?: number;
    /**
     * Maximum number of results returned
     * @type {number}
     * @memberof V3StopDepartureRequest
     */
    maxResults?: number;
    /**
     * Indicates that stop_id parameter will accept \"GTFS stop_id\" data and route_directions[x].route_id parameters will accept route_gtfs_id data
     * @type {boolean}
     * @memberof V3StopDepartureRequest
     */
    gtfs?: boolean;
    /**
     * The route directions to find departures for at this stop.
     * @type {Array<V3StopDepartureRequestRouteDirection>}
     * @memberof V3StopDepartureRequest
     */
    routeDirections: Array<V3StopDepartureRequestRouteDirection>;
}

/**
 * @export
 * @namespace V3StopDepartureRequest
 */
export namespace V3StopDepartureRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum RouteTypeEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_3 = <any> 3,
        NUMBER_4 = <any> 4
    }
}

/**
 * 
 * @export
 * @interface V3StopDepartureRequestRouteDirection
 */
export interface V3StopDepartureRequestRouteDirection {
    /**
     * Identifier of route; values returned by Routes API - v3/routes
     * @type {string}
     * @memberof V3StopDepartureRequestRouteDirection
     */
    routeId?: string;
    /**
     * Direction of travel identifier; values returned by Directions API - v3/directions
     * @type {number}
     * @memberof V3StopDepartureRequestRouteDirection
     */
    directionId?: number;
    /**
     * Name of direction of travel; values returned by Directions API - v3/directions
     * @type {string}
     * @memberof V3StopDepartureRequestRouteDirection
     */
    directionName: string;
}

/**
 * 
 * @export
 * @interface V3StopDetails
 */
export interface V3StopDetails {
    /**
     * Disruption information identifier(s)
     * @type {Array<number>}
     * @memberof V3StopDetails
     */
    disruptionIds?: Array<number>;
    /**
     * Type of metropolitan train station (i.e. \"Premium\", \"Host\" or \"Unstaffed\" station); returns null for V/Line train
     * @type {string}
     * @memberof V3StopDetails
     */
    stationType?: string;
    /**
     * The definition applicable to the station_type; returns null for V/Line train
     * @type {string}
     * @memberof V3StopDetails
     */
    stationDescription?: string;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3StopDetails
     */
    routeType?: number;
    /**
     * Location details of the stop
     * @type {V3StopLocation}
     * @memberof V3StopDetails
     */
    stopLocation?: V3StopLocation;
    /**
     * Amenity and facility details at the stop
     * @type {V3StopAmenityDetails}
     * @memberof V3StopDetails
     */
    stopAmenities?: V3StopAmenityDetails;
    /**
     * Facilities relating to the accessibility of the stop
     * @type {V3StopAccessibility}
     * @memberof V3StopDetails
     */
    stopAccessibility?: V3StopAccessibility;
    /**
     * Staffing details for the stop
     * @type {V3StopStaffing}
     * @memberof V3StopDetails
     */
    stopStaffing?: V3StopStaffing;
    /**
     * Routes travelling through the stop
     * @type {Array<any>}
     * @memberof V3StopDetails
     */
    routes?: Array<any>;
    /**
     * Stop identifier
     * @type {number}
     * @memberof V3StopDetails
     */
    stopId?: number;
    /**
     * Name of stop
     * @type {string}
     * @memberof V3StopDetails
     */
    stopName?: string;
    /**
     * Landmark in proximity of stop
     * @type {string}
     * @memberof V3StopDetails
     */
    stopLandmark?: string;
}

/**
 * 
 * @export
 * @interface V3StopGeosearch
 */
export interface V3StopGeosearch {
    /**
     * Disruption information identifier(s)
     * @type {Array<number>}
     * @memberof V3StopGeosearch
     */
    disruptionIds?: Array<number>;
    /**
     * Distance of stop from input location (in metres); returns 0 if no location is input
     * @type {number}
     * @memberof V3StopGeosearch
     */
    stopDistance?: number;
    /**
     * suburb of stop
     * @type {string}
     * @memberof V3StopGeosearch
     */
    stopSuburb?: string;
    /**
     * Name of stop
     * @type {string}
     * @memberof V3StopGeosearch
     */
    stopName?: string;
    /**
     * Stop identifier
     * @type {number}
     * @memberof V3StopGeosearch
     */
    stopId?: number;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3StopGeosearch
     */
    routeType?: number;
    /**
     * List of routes travelling through the stop
     * @type {Array<any>}
     * @memberof V3StopGeosearch
     */
    routes?: Array<any>;
    /**
     * Geographic coordinate of latitude at stop
     * @type {number}
     * @memberof V3StopGeosearch
     */
    stopLatitude?: number;
    /**
     * Geographic coordinate of longitude at stop
     * @type {number}
     * @memberof V3StopGeosearch
     */
    stopLongitude?: number;
    /**
     * Landmark in proximity of stop
     * @type {string}
     * @memberof V3StopGeosearch
     */
    stopLandmark?: string;
    /**
     * Sequence of the stop on the route/run; return 0 when route_id or run_id not specified. Order ascendingly by this field (when non zero) to get physical order (earliest first) of stops on the route_id/run_id.
     * @type {number}
     * @memberof V3StopGeosearch
     */
    stopSequence?: number;
}

/**
 * 
 * @export
 * @interface V3StopGps
 */
export interface V3StopGps {
    /**
     * Geographic coordinate of latitude at stop
     * @type {number}
     * @memberof V3StopGps
     */
    latitude?: number;
    /**
     * Geographic coordinate of longitude at stop
     * @type {number}
     * @memberof V3StopGps
     */
    longitude?: number;
}

/**
 * 
 * @export
 * @interface V3StopLocation
 */
export interface V3StopLocation {
    /**
     * GPS coordinates of the stop
     * @type {V3StopGps}
     * @memberof V3StopLocation
     */
    gps?: V3StopGps;
}

/**
 * 
 * @export
 * @interface V3StopModel
 */
export interface V3StopModel {
    /**
     * Distance of stop from input location (in metres); returns 0 if no location is input
     * @type {number}
     * @memberof V3StopModel
     */
    stopDistance?: number;
    /**
     * suburb of stop
     * @type {string}
     * @memberof V3StopModel
     */
    stopSuburb?: string;
    /**
     * Name of stop
     * @type {string}
     * @memberof V3StopModel
     */
    stopName?: string;
    /**
     * Stop identifier
     * @type {number}
     * @memberof V3StopModel
     */
    stopId?: number;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3StopModel
     */
    routeType?: number;
    /**
     * Geographic coordinate of latitude at stop
     * @type {number}
     * @memberof V3StopModel
     */
    stopLatitude?: number;
    /**
     * Geographic coordinate of longitude at stop
     * @type {number}
     * @memberof V3StopModel
     */
    stopLongitude?: number;
    /**
     * Landmark in proximity of stop
     * @type {string}
     * @memberof V3StopModel
     */
    stopLandmark?: string;
    /**
     * Sequence of the stop on the route/run; return 0 when route_id or run_id not specified. Order ascendingly by this field (when non zero) to get physical order (earliest first) of stops on the route_id/run_id.
     * @type {number}
     * @memberof V3StopModel
     */
    stopSequence?: number;
}

/**
 * 
 * @export
 * @interface V3StopOnRoute
 */
export interface V3StopOnRoute {
    /**
     * Disruption information identifier(s)
     * @type {Array<number>}
     * @memberof V3StopOnRoute
     */
    disruptionIds?: Array<number>;
    /**
     * suburb of stop
     * @type {string}
     * @memberof V3StopOnRoute
     */
    stopSuburb?: string;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3StopOnRoute
     */
    routeType?: number;
    /**
     * Geographic coordinate of latitude at stop
     * @type {number}
     * @memberof V3StopOnRoute
     */
    stopLatitude?: number;
    /**
     * Geographic coordinate of longitude at stop
     * @type {number}
     * @memberof V3StopOnRoute
     */
    stopLongitude?: number;
    /**
     * Sequence of the stop on the route/run; return 0 when route_id or run_id not specified. Order ascendingly by this field (when non zero) to get physical order (earliest first) of stops on the route_id/run_id.
     * @type {number}
     * @memberof V3StopOnRoute
     */
    stopSequence?: number;
    /**
     * Stop ticket information
     * @type {V3StopTicket}
     * @memberof V3StopOnRoute
     */
    stopTicket?: V3StopTicket;
    /**
     * Stop identifier
     * @type {number}
     * @memberof V3StopOnRoute
     */
    stopId?: number;
    /**
     * Name of stop
     * @type {string}
     * @memberof V3StopOnRoute
     */
    stopName?: string;
    /**
     * Landmark in proximity of stop
     * @type {string}
     * @memberof V3StopOnRoute
     */
    stopLandmark?: string;
}

/**
 * 
 * @export
 * @interface V3StopPoint
 */
export interface V3StopPoint {
    /**
     * 
     * @type {number}
     * @memberof V3StopPoint
     */
    stopId?: number;
}

/**
 * 
 * @export
 * @interface V3StopResponse
 */
export interface V3StopResponse {
    /**
     * A metropolitan or V/Line train station
     * @type {V3StopDetails}
     * @memberof V3StopResponse
     */
    stop?: V3StopDetails;
    /**
     * Disruption information applicable to relevant routes or stops
     * @type {{ [key: string]: V3Disruption; }}
     * @memberof V3StopResponse
     */
    disruptions?: { [key: string]: V3Disruption; };
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3StopResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3StopStaffing
 */
export interface V3StopStaffing {
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    friAmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    friAmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    friPmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    friPmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    monAmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    monAmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    monPmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    monPmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    phAdditionalText?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    phFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    phTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    satAmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    satAmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    satPmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    satPmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    sunAmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    sunAmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    sunPmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    sunPmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    thuAmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    thuAmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    thuPmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    thuPmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    tueAmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    tueAmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    tuePmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    tuePmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    wedAmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    wedAmTo?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    wedPmFrom?: string;
    /**
     * Stop staffing hours
     * @type {string}
     * @memberof V3StopStaffing
     */
    wedPmTo?: string;
}

/**
 * 
 * @export
 * @interface V3StopTicket
 */
export interface V3StopTicket {
    /**
     * Indicates the ticket type for the stop (myki, paper or both)
     * @type {string}
     * @memberof V3StopTicket
     */
    ticketType?: string;
    /**
     * Description of the zone
     * @type {string}
     * @memberof V3StopTicket
     */
    zone?: string;
    /**
     * Indicates whether the stop is inside the free fare zone
     * @type {boolean}
     * @memberof V3StopTicket
     */
    isFreeFareZone?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V3StopTicket
     */
    ticketMachine?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V3StopTicket
     */
    ticketChecks?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V3StopTicket
     */
    vlineReservation?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof V3StopTicket
     */
    ticketZones?: Array<number>;
}

/**
 * 
 * @export
 * @interface V3StoppingPattern
 */
export interface V3StoppingPattern {
    /**
     * Disruption information applicable to relevant routes or stops
     * @type {Array<V3Disruption>}
     * @memberof V3StoppingPattern
     */
    disruptions?: Array<V3Disruption>;
    /**
     * Timetabled and real-time service departures
     * @type {Array<V3PatternDeparture>}
     * @memberof V3StoppingPattern
     */
    departures?: Array<V3PatternDeparture>;
    /**
     * A train station, tram stop, bus stop, regional coach stop or Night Bus stop
     * @type {{ [key: string]: V3StoppingPatternStop; }}
     * @memberof V3StoppingPattern
     */
    stops?: { [key: string]: V3StoppingPatternStop; };
    /**
     * Train lines, tram routes, bus routes, regional coach routes, Night Bus routes
     * @type {{ [key: string]: any; }}
     * @memberof V3StoppingPattern
     */
    routes?: { [key: string]: any; };
    /**
     * Individual trips/services of a route
     * @type {{ [key: string]: V3Run; }}
     * @memberof V3StoppingPattern
     */
    runs?: { [key: string]: V3Run; };
    /**
     * Directions of travel of route
     * @type {{ [key: string]: V3Direction; }}
     * @memberof V3StoppingPattern
     */
    directions?: { [key: string]: V3Direction; };
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3StoppingPattern
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3StoppingPatternStop
 */
export interface V3StoppingPatternStop {
    /**
     * Stop ticket information
     * @type {V3StopTicket}
     * @memberof V3StoppingPatternStop
     */
    stopTicket?: V3StopTicket;
    /**
     * Distance of stop from input location (in metres); returns 0 if no location is input
     * @type {number}
     * @memberof V3StoppingPatternStop
     */
    stopDistance?: number;
    /**
     * suburb of stop
     * @type {string}
     * @memberof V3StoppingPatternStop
     */
    stopSuburb?: string;
    /**
     * Name of stop
     * @type {string}
     * @memberof V3StoppingPatternStop
     */
    stopName?: string;
    /**
     * Stop identifier
     * @type {number}
     * @memberof V3StoppingPatternStop
     */
    stopId?: number;
    /**
     * Transport mode identifier
     * @type {number}
     * @memberof V3StoppingPatternStop
     */
    routeType?: number;
    /**
     * Geographic coordinate of latitude at stop
     * @type {number}
     * @memberof V3StoppingPatternStop
     */
    stopLatitude?: number;
    /**
     * Geographic coordinate of longitude at stop
     * @type {number}
     * @memberof V3StoppingPatternStop
     */
    stopLongitude?: number;
    /**
     * Landmark in proximity of stop
     * @type {string}
     * @memberof V3StoppingPatternStop
     */
    stopLandmark?: string;
    /**
     * Sequence of the stop on the route/run; return 0 when route_id or run_id not specified. Order ascendingly by this field (when non zero) to get physical order (earliest first) of stops on the route_id/run_id.
     * @type {number}
     * @memberof V3StoppingPatternStop
     */
    stopSequence?: number;
}

/**
 * 
 * @export
 * @interface V3StopsByDistanceResponse
 */
export interface V3StopsByDistanceResponse {
    /**
     * Train stations, tram stops, bus stops, regional coach stops or Night Bus stops
     * @type {Array<V3StopGeosearch>}
     * @memberof V3StopsByDistanceResponse
     */
    stops?: Array<V3StopGeosearch>;
    /**
     * Disruption information applicable to relevant routes or stops
     * @type {{ [key: string]: V3Disruption; }}
     * @memberof V3StopsByDistanceResponse
     */
    disruptions?: { [key: string]: V3Disruption; };
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3StopsByDistanceResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3StopsOnRouteResponse
 */
export interface V3StopsOnRouteResponse {
    /**
     * Train stations, tram stops, bus stops, regional coach stops or Night Bus stops
     * @type {Array<V3StopOnRoute>}
     * @memberof V3StopsOnRouteResponse
     */
    stops?: Array<V3StopOnRoute>;
    /**
     * Disruption information applicable to relevant routes or stops
     * @type {{ [key: string]: V3Disruption; }}
     * @memberof V3StopsOnRouteResponse
     */
    disruptions?: { [key: string]: V3Disruption; };
    /**
     * GeoPath for the route
     * @type {Array<any>}
     * @memberof V3StopsOnRouteResponse
     */
    geopath?: Array<any>;
    /**
     * API Status / Metadata
     * @type {V3Status}
     * @memberof V3StopsOnRouteResponse
     */
    status?: V3Status;
}

/**
 * 
 * @export
 * @interface V3VehicleDescriptor
 */
export interface V3VehicleDescriptor {
    /**
     * Operator name of the vehicle such as \"Metro Trains Melbourne\", \"Yarra Trams\", \"Ventura Bus Line\", \"CDC\" or \"Sita Bus Lines\" . May be null/empty.  Only available for train, tram, v/line and some bus runs.
     * @type {string}
     * @memberof V3VehicleDescriptor
     */
    operator?: string;
    /**
     * Operator identifier of the vehicle such as \"26094\". May be null/empty. Only available for some tram and bus runs.
     * @type {string}
     * @memberof V3VehicleDescriptor
     */
    id?: string;
    /**
     * Indicator if vehicle has a low floor. May be null. Only available for some tram runs.
     * @type {boolean}
     * @memberof V3VehicleDescriptor
     */
    lowFloor?: boolean;
    /**
     * Indicator if vehicle is air conditioned. May be null. Only available for some tram runs.
     * @type {boolean}
     * @memberof V3VehicleDescriptor
     */
    airConditioned?: boolean;
    /**
     * Vehicle description such as \"6 Car Comeng\", \"6 Car Xtrapolis\", \"3 Car Comeng\", \"6 Car Siemens\", \"3 Car Siemens\". May be null/empty.  Only available for some metropolitan train runs.
     * @type {string}
     * @memberof V3VehicleDescriptor
     */
    description?: string;
    /**
     * Supplier of vehicle descriptor data.
     * @type {string}
     * @memberof V3VehicleDescriptor
     */
    supplier?: string;
    /**
     * The length of the vehicle. Applies to CIS - Metro Trains
     * @type {string}
     * @memberof V3VehicleDescriptor
     */
    length?: string;
}

/**
 * 
 * @export
 * @interface V3VehiclePosition
 */
export interface V3VehiclePosition {
    /**
     * Geographic coordinate of latitude of the vehicle when known. May be null.  Only available for some bus runs.
     * @type {number}
     * @memberof V3VehiclePosition
     */
    latitude?: number;
    /**
     * Geographic coordinate of longitude of the vehicle when known.   Only available for some bus runs.
     * @type {number}
     * @memberof V3VehiclePosition
     */
    longitude?: number;
    /**
     * CIS - Metro Train Vehicle Location Easting coordinate
     * @type {number}
     * @memberof V3VehiclePosition
     */
    easting?: number;
    /**
     * CIS - Metro Train Vehicle Location Northing coordinate
     * @type {number}
     * @memberof V3VehiclePosition
     */
    northing?: number;
    /**
     * CIS - Metro Train Vehicle Location Direction
     * @type {string}
     * @memberof V3VehiclePosition
     */
    direction?: string;
    /**
     * Compass bearing of the vehicle when known, clockwise from True North, i.e., 0 is North and 90 is East. May be null.  Only available for some bus runs.
     * @type {number}
     * @memberof V3VehiclePosition
     */
    bearing?: number;
    /**
     * Supplier of vehicle position data.
     * @type {string}
     * @memberof V3VehiclePosition
     */
    supplier?: string;
    /**
     * Date and time that the vehicle position data was supplied.
     * @type {Date}
     * @memberof V3VehiclePosition
     */
    datetimeUtc?: Date;
    /**
     * CIS - Metro Train Vehicle Location data expiry time
     * @type {Date}
     * @memberof V3VehiclePosition
     */
    expiryTime?: Date;
}

/**
 * 
 * @export
 * @interface V3Void
 */
export interface V3Void {
}

/**
 * 
 * @export
 * @interface V3ZoneInfo
 */
export interface V3ZoneInfo {
    /**
     * 
     * @type {number}
     * @memberof V3ZoneInfo
     */
    minZone?: number;
    /**
     * 
     * @type {number}
     * @memberof V3ZoneInfo
     */
    maxZone?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof V3ZoneInfo
     */
    uniqueZones?: Array<number>;
}


/**
 * DeparturesApi - fetch parameter creator
 * @export
 */
export const DeparturesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View departures for all routes from a stop
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {number} stopId Identifier of stop; values returned by Stops API
         * @param {Array<number>} [platformNumbers] Filter by platform number at stop
         * @param {number} [directionId] Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {boolean} [gtfs] Indicates that stop_id parameter will accept \&quot;GTFS stop_id\&quot; data
         * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format) (default &#x3D; current date and time)
         * @param {number} [maxResults] Maximum number of results returned
         * @param {boolean} [includeCancelled] Indicates if cancelled services (if they exist) are returned (default &#x3D; false) - metropolitan train only
         * @param {boolean} [lookBackwards] Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default &#x3D; false). Requires max_results &amp;gt; 0.
         * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
         * @param {boolean} [includeGeopath] Indicates if the route geopath should be returned
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departuresGetForStop(routeType: 0 | 1 | 2 | 3 | 4, stopId: number, platformNumbers?: Array<number>, directionId?: number, gtfs?: boolean, dateUtc?: Date, maxResults?: number, includeCancelled?: boolean, lookBackwards?: boolean, expand?: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'routeType' is not null or undefined
            if (routeType === null || routeType === undefined) {
                throw new RequiredError('routeType','Required parameter routeType was null or undefined when calling departuresGetForStop.');
            }
            // verify required parameter 'stopId' is not null or undefined
            if (stopId === null || stopId === undefined) {
                throw new RequiredError('stopId','Required parameter stopId was null or undefined when calling departuresGetForStop.');
            }
            const localVarPath = `/v3/departures/route_type/{route_type}/stop/{stop_id}`
                .replace(`{${"route_type"}}`, encodeURIComponent(String(routeType)))
                .replace(`{${"stop_id"}}`, encodeURIComponent(String(stopId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (platformNumbers) {
                localVarQueryParameter['platform_numbers'] = platformNumbers;
            }

            if (directionId !== undefined) {
                localVarQueryParameter['direction_id'] = directionId;
            }

            if (gtfs !== undefined) {
                localVarQueryParameter['gtfs'] = gtfs;
            }

            if (dateUtc !== undefined) {
                localVarQueryParameter['date_utc'] = (dateUtc as any).toISOString();
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (includeCancelled !== undefined) {
                localVarQueryParameter['include_cancelled'] = includeCancelled;
            }

            if (lookBackwards !== undefined) {
                localVarQueryParameter['look_backwards'] = lookBackwards;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (includeGeopath !== undefined) {
                localVarQueryParameter['include_geopath'] = includeGeopath;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View departures for a specific route from a stop
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {number} stopId Identifier of stop; values returned by Stops API
         * @param {string} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {number} [directionId] Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {boolean} [gtfs] Indicates that stop_id parameter will accept \&quot;GTFS stop_id\&quot; data
         * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format) (default &#x3D; current date and time)
         * @param {number} [maxResults] Maximum number of results returned
         * @param {boolean} [includeCancelled] Indicates if cancelled services (if they exist) are returned (default &#x3D; false) - metropolitan train only
         * @param {boolean} [lookBackwards] Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default &#x3D; false). Requires max_results &amp;gt; 0.
         * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
         * @param {boolean} [includeGeopath] Indicates if the route geopath should be returned
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departuresGetForStopAndRoute(routeType: 0 | 1 | 2 | 3 | 4, stopId: number, routeId: string, directionId?: number, gtfs?: boolean, dateUtc?: Date, maxResults?: number, includeCancelled?: boolean, lookBackwards?: boolean, expand?: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'routeType' is not null or undefined
            if (routeType === null || routeType === undefined) {
                throw new RequiredError('routeType','Required parameter routeType was null or undefined when calling departuresGetForStopAndRoute.');
            }
            // verify required parameter 'stopId' is not null or undefined
            if (stopId === null || stopId === undefined) {
                throw new RequiredError('stopId','Required parameter stopId was null or undefined when calling departuresGetForStopAndRoute.');
            }
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling departuresGetForStopAndRoute.');
            }
            const localVarPath = `/v3/departures/route_type/{route_type}/stop/{stop_id}/route/{route_id}`
                .replace(`{${"route_type"}}`, encodeURIComponent(String(routeType)))
                .replace(`{${"stop_id"}}`, encodeURIComponent(String(stopId)))
                .replace(`{${"route_id"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (directionId !== undefined) {
                localVarQueryParameter['direction_id'] = directionId;
            }

            if (gtfs !== undefined) {
                localVarQueryParameter['gtfs'] = gtfs;
            }

            if (dateUtc !== undefined) {
                localVarQueryParameter['date_utc'] = (dateUtc as any).toISOString();
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (includeCancelled !== undefined) {
                localVarQueryParameter['include_cancelled'] = includeCancelled;
            }

            if (lookBackwards !== undefined) {
                localVarQueryParameter['look_backwards'] = lookBackwards;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (includeGeopath !== undefined) {
                localVarQueryParameter['include_geopath'] = includeGeopath;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeparturesApi - functional programming interface
 * @export
 */
export const DeparturesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View departures for all routes from a stop
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {number} stopId Identifier of stop; values returned by Stops API
         * @param {Array<number>} [platformNumbers] Filter by platform number at stop
         * @param {number} [directionId] Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {boolean} [gtfs] Indicates that stop_id parameter will accept \&quot;GTFS stop_id\&quot; data
         * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format) (default &#x3D; current date and time)
         * @param {number} [maxResults] Maximum number of results returned
         * @param {boolean} [includeCancelled] Indicates if cancelled services (if they exist) are returned (default &#x3D; false) - metropolitan train only
         * @param {boolean} [lookBackwards] Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default &#x3D; false). Requires max_results &amp;gt; 0.
         * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
         * @param {boolean} [includeGeopath] Indicates if the route geopath should be returned
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departuresGetForStop(routeType: 0 | 1 | 2 | 3 | 4, stopId: number, platformNumbers?: Array<number>, directionId?: number, gtfs?: boolean, dateUtc?: Date, maxResults?: number, includeCancelled?: boolean, lookBackwards?: boolean, expand?: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DeparturesResponse> {
            const localVarFetchArgs = DeparturesApiFetchParamCreator(configuration).departuresGetForStop(routeType, stopId, platformNumbers, directionId, gtfs, dateUtc, maxResults, includeCancelled, lookBackwards, expand, includeGeopath, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View departures for a specific route from a stop
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {number} stopId Identifier of stop; values returned by Stops API
         * @param {string} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {number} [directionId] Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {boolean} [gtfs] Indicates that stop_id parameter will accept \&quot;GTFS stop_id\&quot; data
         * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format) (default &#x3D; current date and time)
         * @param {number} [maxResults] Maximum number of results returned
         * @param {boolean} [includeCancelled] Indicates if cancelled services (if they exist) are returned (default &#x3D; false) - metropolitan train only
         * @param {boolean} [lookBackwards] Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default &#x3D; false). Requires max_results &amp;gt; 0.
         * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
         * @param {boolean} [includeGeopath] Indicates if the route geopath should be returned
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departuresGetForStopAndRoute(routeType: 0 | 1 | 2 | 3 | 4, stopId: number, routeId: string, directionId?: number, gtfs?: boolean, dateUtc?: Date, maxResults?: number, includeCancelled?: boolean, lookBackwards?: boolean, expand?: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DeparturesResponse> {
            const localVarFetchArgs = DeparturesApiFetchParamCreator(configuration).departuresGetForStopAndRoute(routeType, stopId, routeId, directionId, gtfs, dateUtc, maxResults, includeCancelled, lookBackwards, expand, includeGeopath, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeparturesApi - factory interface
 * @export
 */
export const DeparturesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary View departures for all routes from a stop
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {number} stopId Identifier of stop; values returned by Stops API
         * @param {Array<number>} [platformNumbers] Filter by platform number at stop
         * @param {number} [directionId] Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {boolean} [gtfs] Indicates that stop_id parameter will accept \&quot;GTFS stop_id\&quot; data
         * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format) (default &#x3D; current date and time)
         * @param {number} [maxResults] Maximum number of results returned
         * @param {boolean} [includeCancelled] Indicates if cancelled services (if they exist) are returned (default &#x3D; false) - metropolitan train only
         * @param {boolean} [lookBackwards] Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default &#x3D; false). Requires max_results &amp;gt; 0.
         * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
         * @param {boolean} [includeGeopath] Indicates if the route geopath should be returned
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departuresGetForStop(routeType: 0 | 1 | 2 | 3 | 4, stopId: number, platformNumbers?: Array<number>, directionId?: number, gtfs?: boolean, dateUtc?: Date, maxResults?: number, includeCancelled?: boolean, lookBackwards?: boolean, expand?: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
            return DeparturesApiFp(configuration).departuresGetForStop(routeType, stopId, platformNumbers, directionId, gtfs, dateUtc, maxResults, includeCancelled, lookBackwards, expand, includeGeopath, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View departures for a specific route from a stop
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {number} stopId Identifier of stop; values returned by Stops API
         * @param {string} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {number} [directionId] Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {boolean} [gtfs] Indicates that stop_id parameter will accept \&quot;GTFS stop_id\&quot; data
         * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format) (default &#x3D; current date and time)
         * @param {number} [maxResults] Maximum number of results returned
         * @param {boolean} [includeCancelled] Indicates if cancelled services (if they exist) are returned (default &#x3D; false) - metropolitan train only
         * @param {boolean} [lookBackwards] Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default &#x3D; false). Requires max_results &amp;gt; 0.
         * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
         * @param {boolean} [includeGeopath] Indicates if the route geopath should be returned
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departuresGetForStopAndRoute(routeType: 0 | 1 | 2 | 3 | 4, stopId: number, routeId: string, directionId?: number, gtfs?: boolean, dateUtc?: Date, maxResults?: number, includeCancelled?: boolean, lookBackwards?: boolean, expand?: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
            return DeparturesApiFp(configuration).departuresGetForStopAndRoute(routeType, stopId, routeId, directionId, gtfs, dateUtc, maxResults, includeCancelled, lookBackwards, expand, includeGeopath, token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * DeparturesApi - object-oriented interface
 * @export
 * @class DeparturesApi
 * @extends {BaseAPI}
 */
export class DeparturesApi extends BaseAPI {
    /**
     * 
     * @summary View departures for all routes from a stop
     * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
     * @param {number} stopId Identifier of stop; values returned by Stops API
     * @param {Array<number>} [platformNumbers] Filter by platform number at stop
     * @param {number} [directionId] Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
     * @param {boolean} [gtfs] Indicates that stop_id parameter will accept \&quot;GTFS stop_id\&quot; data
     * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format) (default &#x3D; current date and time)
     * @param {number} [maxResults] Maximum number of results returned
     * @param {boolean} [includeCancelled] Indicates if cancelled services (if they exist) are returned (default &#x3D; false) - metropolitan train only
     * @param {boolean} [lookBackwards] Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default &#x3D; false). Requires max_results &amp;gt; 0.
     * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
     * @param {boolean} [includeGeopath] Indicates if the route geopath should be returned
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeparturesApi
     */
    public departuresGetForStop(routeType: 0 | 1 | 2 | 3 | 4, stopId: number, platformNumbers?: Array<number>, directionId?: number, gtfs?: boolean, dateUtc?: Date, maxResults?: number, includeCancelled?: boolean, lookBackwards?: boolean, expand?: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
        return DeparturesApiFp(this.configuration).departuresGetForStop(routeType, stopId, platformNumbers, directionId, gtfs, dateUtc, maxResults, includeCancelled, lookBackwards, expand, includeGeopath, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View departures for a specific route from a stop
     * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
     * @param {number} stopId Identifier of stop; values returned by Stops API
     * @param {string} routeId Identifier of route; values returned by Routes API - v3/routes
     * @param {number} [directionId] Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
     * @param {boolean} [gtfs] Indicates that stop_id parameter will accept \&quot;GTFS stop_id\&quot; data
     * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format) (default &#x3D; current date and time)
     * @param {number} [maxResults] Maximum number of results returned
     * @param {boolean} [includeCancelled] Indicates if cancelled services (if they exist) are returned (default &#x3D; false) - metropolitan train only
     * @param {boolean} [lookBackwards] Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default &#x3D; false). Requires max_results &amp;gt; 0.
     * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.  Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
     * @param {boolean} [includeGeopath] Indicates if the route geopath should be returned
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeparturesApi
     */
    public departuresGetForStopAndRoute(routeType: 0 | 1 | 2 | 3 | 4, stopId: number, routeId: string, directionId?: number, gtfs?: boolean, dateUtc?: Date, maxResults?: number, includeCancelled?: boolean, lookBackwards?: boolean, expand?: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
        return DeparturesApiFp(this.configuration).departuresGetForStopAndRoute(routeType, stopId, routeId, directionId, gtfs, dateUtc, maxResults, includeCancelled, lookBackwards, expand, includeGeopath, token, devid, signature, options)(this.fetch, this.basePath);
    }

}

/**
 * DirectionsApi - fetch parameter creator
 * @export
 */
export const DirectionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View all routes for a direction of travel
         * @param {number} directionId Identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directionsForDirection(directionId: number, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'directionId' is not null or undefined
            if (directionId === null || directionId === undefined) {
                throw new RequiredError('directionId','Required parameter directionId was null or undefined when calling directionsForDirection.');
            }
            const localVarPath = `/v3/directions/{direction_id}`
                .replace(`{${"direction_id"}}`, encodeURIComponent(String(directionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View all routes of a particular type for a direction of travel
         * @param {number} directionId Identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directionsForDirectionAndType(directionId: number, routeType: 0 | 1 | 2 | 3 | 4, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'directionId' is not null or undefined
            if (directionId === null || directionId === undefined) {
                throw new RequiredError('directionId','Required parameter directionId was null or undefined when calling directionsForDirectionAndType.');
            }
            // verify required parameter 'routeType' is not null or undefined
            if (routeType === null || routeType === undefined) {
                throw new RequiredError('routeType','Required parameter routeType was null or undefined when calling directionsForDirectionAndType.');
            }
            const localVarPath = `/v3/directions/{direction_id}/route_type/{route_type}`
                .replace(`{${"direction_id"}}`, encodeURIComponent(String(directionId)))
                .replace(`{${"route_type"}}`, encodeURIComponent(String(routeType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View directions that a route travels in
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directionsForRoute(routeId: number, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling directionsForRoute.');
            }
            const localVarPath = `/v3/directions/route/{route_id}`
                .replace(`{${"route_id"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DirectionsApi - functional programming interface
 * @export
 */
export const DirectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View all routes for a direction of travel
         * @param {number} directionId Identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directionsForDirection(directionId: number, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DirectionsResponse> {
            const localVarFetchArgs = DirectionsApiFetchParamCreator(configuration).directionsForDirection(directionId, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View all routes of a particular type for a direction of travel
         * @param {number} directionId Identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directionsForDirectionAndType(directionId: number, routeType: 0 | 1 | 2 | 3 | 4, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DirectionsResponse> {
            const localVarFetchArgs = DirectionsApiFetchParamCreator(configuration).directionsForDirectionAndType(directionId, routeType, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View directions that a route travels in
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directionsForRoute(routeId: number, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DirectionsResponse> {
            const localVarFetchArgs = DirectionsApiFetchParamCreator(configuration).directionsForRoute(routeId, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DirectionsApi - factory interface
 * @export
 */
export const DirectionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary View all routes for a direction of travel
         * @param {number} directionId Identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directionsForDirection(directionId: number, token?: string, devid?: string, signature?: string, options?: any) {
            return DirectionsApiFp(configuration).directionsForDirection(directionId, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View all routes of a particular type for a direction of travel
         * @param {number} directionId Identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directionsForDirectionAndType(directionId: number, routeType: 0 | 1 | 2 | 3 | 4, token?: string, devid?: string, signature?: string, options?: any) {
            return DirectionsApiFp(configuration).directionsForDirectionAndType(directionId, routeType, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View directions that a route travels in
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directionsForRoute(routeId: number, token?: string, devid?: string, signature?: string, options?: any) {
            return DirectionsApiFp(configuration).directionsForRoute(routeId, token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * DirectionsApi - object-oriented interface
 * @export
 * @class DirectionsApi
 * @extends {BaseAPI}
 */
export class DirectionsApi extends BaseAPI {
    /**
     * 
     * @summary View all routes for a direction of travel
     * @param {number} directionId Identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectionsApi
     */
    public directionsForDirection(directionId: number, token?: string, devid?: string, signature?: string, options?: any) {
        return DirectionsApiFp(this.configuration).directionsForDirection(directionId, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View all routes of a particular type for a direction of travel
     * @param {number} directionId Identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}
     * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectionsApi
     */
    public directionsForDirectionAndType(directionId: number, routeType: 0 | 1 | 2 | 3 | 4, token?: string, devid?: string, signature?: string, options?: any) {
        return DirectionsApiFp(this.configuration).directionsForDirectionAndType(directionId, routeType, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View directions that a route travels in
     * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectionsApi
     */
    public directionsForRoute(routeId: number, token?: string, devid?: string, signature?: string, options?: any) {
        return DirectionsApiFp(this.configuration).directionsForRoute(routeId, token, devid, signature, options)(this.fetch, this.basePath);
    }

}

/**
 * DisruptionsApi - fetch parameter creator
 * @export
 */
export const DisruptionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View all disruptions for all route types
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
         * @param {Array<1 | 2 | 3 | 4 | 5 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 100>} [disruptionModes] Filter by disruption_mode; values returned via v3/disruptions/modes API
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetAllDisruptions(routeTypes?: Array<0 | 1 | 2 | 3 | 4>, disruptionModes?: Array<1 | 2 | 3 | 4 | 5 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 100>, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/disruptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (routeTypes) {
                localVarQueryParameter['route_types'] = routeTypes;
            }

            if (disruptionModes) {
                localVarQueryParameter['disruption_modes'] = disruptionModes;
            }

            if (disruptionStatus !== undefined) {
                localVarQueryParameter['disruption_status'] = disruptionStatus;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View a specific disruption
         * @param {number} disruptionId Identifier of disruption; values returned by Disruptions API - /v3/disruptions OR /v3/disruptions/route/{route_id}
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionById(disruptionId: number, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'disruptionId' is not null or undefined
            if (disruptionId === null || disruptionId === undefined) {
                throw new RequiredError('disruptionId','Required parameter disruptionId was null or undefined when calling disruptionsGetDisruptionById.');
            }
            const localVarPath = `/v3/disruptions/{disruption_id}`
                .replace(`{${"disruption_id"}}`, encodeURIComponent(String(disruptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all disruption modes
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionModes(token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/disruptions/modes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View all disruptions for a particular route
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionsByRoute(routeId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling disruptionsGetDisruptionsByRoute.');
            }
            const localVarPath = `/v3/disruptions/route/{route_id}`
                .replace(`{${"route_id"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (disruptionStatus !== undefined) {
                localVarQueryParameter['disruption_status'] = disruptionStatus;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View all disruptions for a particular route and stop
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {number} stopId Identifier of stop; values returned by Stops API - v3/stops
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionsByRouteAndStop(routeId: number, stopId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling disruptionsGetDisruptionsByRouteAndStop.');
            }
            // verify required parameter 'stopId' is not null or undefined
            if (stopId === null || stopId === undefined) {
                throw new RequiredError('stopId','Required parameter stopId was null or undefined when calling disruptionsGetDisruptionsByRouteAndStop.');
            }
            const localVarPath = `/v3/disruptions/route/{route_id}/stop/{stop_id}`
                .replace(`{${"route_id"}}`, encodeURIComponent(String(routeId)))
                .replace(`{${"stop_id"}}`, encodeURIComponent(String(stopId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (disruptionStatus !== undefined) {
                localVarQueryParameter['disruption_status'] = disruptionStatus;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View all disruptions for a particular stop
         * @param {number} stopId Identifier of stop; values returned by Stops API - v3/stops
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionsByStop(stopId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'stopId' is not null or undefined
            if (stopId === null || stopId === undefined) {
                throw new RequiredError('stopId','Required parameter stopId was null or undefined when calling disruptionsGetDisruptionsByStop.');
            }
            const localVarPath = `/v3/disruptions/stop/{stop_id}`
                .replace(`{${"stop_id"}}`, encodeURIComponent(String(stopId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (disruptionStatus !== undefined) {
                localVarQueryParameter['disruption_status'] = disruptionStatus;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisruptionsApi - functional programming interface
 * @export
 */
export const DisruptionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View all disruptions for all route types
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
         * @param {Array<1 | 2 | 3 | 4 | 5 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 100>} [disruptionModes] Filter by disruption_mode; values returned via v3/disruptions/modes API
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetAllDisruptions(routeTypes?: Array<0 | 1 | 2 | 3 | 4>, disruptionModes?: Array<1 | 2 | 3 | 4 | 5 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 100>, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DisruptionsResponse> {
            const localVarFetchArgs = DisruptionsApiFetchParamCreator(configuration).disruptionsGetAllDisruptions(routeTypes, disruptionModes, disruptionStatus, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View a specific disruption
         * @param {number} disruptionId Identifier of disruption; values returned by Disruptions API - /v3/disruptions OR /v3/disruptions/route/{route_id}
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionById(disruptionId: number, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DisruptionResponse> {
            const localVarFetchArgs = DisruptionsApiFetchParamCreator(configuration).disruptionsGetDisruptionById(disruptionId, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all disruption modes
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionModes(token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DisruptionModesResponse> {
            const localVarFetchArgs = DisruptionsApiFetchParamCreator(configuration).disruptionsGetDisruptionModes(token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View all disruptions for a particular route
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionsByRoute(routeId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DisruptionsResponse> {
            const localVarFetchArgs = DisruptionsApiFetchParamCreator(configuration).disruptionsGetDisruptionsByRoute(routeId, disruptionStatus, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View all disruptions for a particular route and stop
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {number} stopId Identifier of stop; values returned by Stops API - v3/stops
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionsByRouteAndStop(routeId: number, stopId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DisruptionsResponse> {
            const localVarFetchArgs = DisruptionsApiFetchParamCreator(configuration).disruptionsGetDisruptionsByRouteAndStop(routeId, stopId, disruptionStatus, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View all disruptions for a particular stop
         * @param {number} stopId Identifier of stop; values returned by Stops API - v3/stops
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionsByStop(stopId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3DisruptionsResponse> {
            const localVarFetchArgs = DisruptionsApiFetchParamCreator(configuration).disruptionsGetDisruptionsByStop(stopId, disruptionStatus, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DisruptionsApi - factory interface
 * @export
 */
export const DisruptionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary View all disruptions for all route types
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
         * @param {Array<1 | 2 | 3 | 4 | 5 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 100>} [disruptionModes] Filter by disruption_mode; values returned via v3/disruptions/modes API
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetAllDisruptions(routeTypes?: Array<0 | 1 | 2 | 3 | 4>, disruptionModes?: Array<1 | 2 | 3 | 4 | 5 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 100>, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any) {
            return DisruptionsApiFp(configuration).disruptionsGetAllDisruptions(routeTypes, disruptionModes, disruptionStatus, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View a specific disruption
         * @param {number} disruptionId Identifier of disruption; values returned by Disruptions API - /v3/disruptions OR /v3/disruptions/route/{route_id}
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionById(disruptionId: number, token?: string, devid?: string, signature?: string, options?: any) {
            return DisruptionsApiFp(configuration).disruptionsGetDisruptionById(disruptionId, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all disruption modes
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionModes(token?: string, devid?: string, signature?: string, options?: any) {
            return DisruptionsApiFp(configuration).disruptionsGetDisruptionModes(token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View all disruptions for a particular route
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionsByRoute(routeId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any) {
            return DisruptionsApiFp(configuration).disruptionsGetDisruptionsByRoute(routeId, disruptionStatus, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View all disruptions for a particular route and stop
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {number} stopId Identifier of stop; values returned by Stops API - v3/stops
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionsByRouteAndStop(routeId: number, stopId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any) {
            return DisruptionsApiFp(configuration).disruptionsGetDisruptionsByRouteAndStop(routeId, stopId, disruptionStatus, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View all disruptions for a particular stop
         * @param {number} stopId Identifier of stop; values returned by Stops API - v3/stops
         * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disruptionsGetDisruptionsByStop(stopId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any) {
            return DisruptionsApiFp(configuration).disruptionsGetDisruptionsByStop(stopId, disruptionStatus, token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * DisruptionsApi - object-oriented interface
 * @export
 * @class DisruptionsApi
 * @extends {BaseAPI}
 */
export class DisruptionsApi extends BaseAPI {
    /**
     * 
     * @summary View all disruptions for all route types
     * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
     * @param {Array<1 | 2 | 3 | 4 | 5 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 100>} [disruptionModes] Filter by disruption_mode; values returned via v3/disruptions/modes API
     * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisruptionsApi
     */
    public disruptionsGetAllDisruptions(routeTypes?: Array<0 | 1 | 2 | 3 | 4>, disruptionModes?: Array<1 | 2 | 3 | 4 | 5 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 100>, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any) {
        return DisruptionsApiFp(this.configuration).disruptionsGetAllDisruptions(routeTypes, disruptionModes, disruptionStatus, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View a specific disruption
     * @param {number} disruptionId Identifier of disruption; values returned by Disruptions API - /v3/disruptions OR /v3/disruptions/route/{route_id}
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisruptionsApi
     */
    public disruptionsGetDisruptionById(disruptionId: number, token?: string, devid?: string, signature?: string, options?: any) {
        return DisruptionsApiFp(this.configuration).disruptionsGetDisruptionById(disruptionId, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all disruption modes
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisruptionsApi
     */
    public disruptionsGetDisruptionModes(token?: string, devid?: string, signature?: string, options?: any) {
        return DisruptionsApiFp(this.configuration).disruptionsGetDisruptionModes(token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View all disruptions for a particular route
     * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
     * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisruptionsApi
     */
    public disruptionsGetDisruptionsByRoute(routeId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any) {
        return DisruptionsApiFp(this.configuration).disruptionsGetDisruptionsByRoute(routeId, disruptionStatus, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View all disruptions for a particular route and stop
     * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
     * @param {number} stopId Identifier of stop; values returned by Stops API - v3/stops
     * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisruptionsApi
     */
    public disruptionsGetDisruptionsByRouteAndStop(routeId: number, stopId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any) {
        return DisruptionsApiFp(this.configuration).disruptionsGetDisruptionsByRouteAndStop(routeId, stopId, disruptionStatus, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View all disruptions for a particular stop
     * @param {number} stopId Identifier of stop; values returned by Stops API - v3/stops
     * @param {'current' | 'planned'} [disruptionStatus] Filter by status of disruption
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisruptionsApi
     */
    public disruptionsGetDisruptionsByStop(stopId: number, disruptionStatus?: 'current' | 'planned', token?: string, devid?: string, signature?: string, options?: any) {
        return DisruptionsApiFp(this.configuration).disruptionsGetDisruptionsByStop(stopId, disruptionStatus, token, devid, signature, options)(this.fetch, this.basePath);
    }

}

/**
 * FareEstimateApi - fetch parameter creator
 * @export
 */
export const FareEstimateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Estimate a fare by zone
         * @param {number} minZone Minimum Zone travelled through ie. 1
         * @param {number} maxZone Maximum Zone travelled through id. 6
         * @param {Date} [journeyTouchOnUtc] JourneyTouchOnUtc in format yyyy-M-d h:m (e.g 2016-5-31 16:53).
         * @param {Date} [journeyTouchOffUtc] JourneyTouchOffUtc in format yyyy-M-d h:m (e.g 2016-5-31 16:53).
         * @param {boolean} [isJourneyInFreeTramZone] 
         * @param {Array<0 | 1 | 2 | 3 | 4>} [travelledRouteTypes] 
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fareEstimateGetFareEstimateByZone(minZone: number, maxZone: number, journeyTouchOnUtc?: Date, journeyTouchOffUtc?: Date, isJourneyInFreeTramZone?: boolean, travelledRouteTypes?: Array<0 | 1 | 2 | 3 | 4>, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'minZone' is not null or undefined
            if (minZone === null || minZone === undefined) {
                throw new RequiredError('minZone','Required parameter minZone was null or undefined when calling fareEstimateGetFareEstimateByZone.');
            }
            // verify required parameter 'maxZone' is not null or undefined
            if (maxZone === null || maxZone === undefined) {
                throw new RequiredError('maxZone','Required parameter maxZone was null or undefined when calling fareEstimateGetFareEstimateByZone.');
            }
            const localVarPath = `/v3/fare_estimate/min_zone/{minZone}/max_zone/{maxZone}`
                .replace(`{${"minZone"}}`, encodeURIComponent(String(minZone)))
                .replace(`{${"maxZone"}}`, encodeURIComponent(String(maxZone)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (journeyTouchOnUtc !== undefined) {
                localVarQueryParameter['journey_touch_on_utc'] = (journeyTouchOnUtc as any).toISOString();
            }

            if (journeyTouchOffUtc !== undefined) {
                localVarQueryParameter['journey_touch_off_utc'] = (journeyTouchOffUtc as any).toISOString();
            }

            if (isJourneyInFreeTramZone !== undefined) {
                localVarQueryParameter['is_journey_in_free_tram_zone'] = isJourneyInFreeTramZone;
            }

            if (travelledRouteTypes) {
                localVarQueryParameter['travelled_route_types'] = travelledRouteTypes;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FareEstimateApi - functional programming interface
 * @export
 */
export const FareEstimateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Estimate a fare by zone
         * @param {number} minZone Minimum Zone travelled through ie. 1
         * @param {number} maxZone Maximum Zone travelled through id. 6
         * @param {Date} [journeyTouchOnUtc] JourneyTouchOnUtc in format yyyy-M-d h:m (e.g 2016-5-31 16:53).
         * @param {Date} [journeyTouchOffUtc] JourneyTouchOffUtc in format yyyy-M-d h:m (e.g 2016-5-31 16:53).
         * @param {boolean} [isJourneyInFreeTramZone] 
         * @param {Array<0 | 1 | 2 | 3 | 4>} [travelledRouteTypes] 
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fareEstimateGetFareEstimateByZone(minZone: number, maxZone: number, journeyTouchOnUtc?: Date, journeyTouchOffUtc?: Date, isJourneyInFreeTramZone?: boolean, travelledRouteTypes?: Array<0 | 1 | 2 | 3 | 4>, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3FareEstimateResponse> {
            const localVarFetchArgs = FareEstimateApiFetchParamCreator(configuration).fareEstimateGetFareEstimateByZone(minZone, maxZone, journeyTouchOnUtc, journeyTouchOffUtc, isJourneyInFreeTramZone, travelledRouteTypes, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FareEstimateApi - factory interface
 * @export
 */
export const FareEstimateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Estimate a fare by zone
         * @param {number} minZone Minimum Zone travelled through ie. 1
         * @param {number} maxZone Maximum Zone travelled through id. 6
         * @param {Date} [journeyTouchOnUtc] JourneyTouchOnUtc in format yyyy-M-d h:m (e.g 2016-5-31 16:53).
         * @param {Date} [journeyTouchOffUtc] JourneyTouchOffUtc in format yyyy-M-d h:m (e.g 2016-5-31 16:53).
         * @param {boolean} [isJourneyInFreeTramZone] 
         * @param {Array<0 | 1 | 2 | 3 | 4>} [travelledRouteTypes] 
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fareEstimateGetFareEstimateByZone(minZone: number, maxZone: number, journeyTouchOnUtc?: Date, journeyTouchOffUtc?: Date, isJourneyInFreeTramZone?: boolean, travelledRouteTypes?: Array<0 | 1 | 2 | 3 | 4>, token?: string, devid?: string, signature?: string, options?: any) {
            return FareEstimateApiFp(configuration).fareEstimateGetFareEstimateByZone(minZone, maxZone, journeyTouchOnUtc, journeyTouchOffUtc, isJourneyInFreeTramZone, travelledRouteTypes, token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * FareEstimateApi - object-oriented interface
 * @export
 * @class FareEstimateApi
 * @extends {BaseAPI}
 */
export class FareEstimateApi extends BaseAPI {
    /**
     * 
     * @summary Estimate a fare by zone
     * @param {number} minZone Minimum Zone travelled through ie. 1
     * @param {number} maxZone Maximum Zone travelled through id. 6
     * @param {Date} [journeyTouchOnUtc] JourneyTouchOnUtc in format yyyy-M-d h:m (e.g 2016-5-31 16:53).
     * @param {Date} [journeyTouchOffUtc] JourneyTouchOffUtc in format yyyy-M-d h:m (e.g 2016-5-31 16:53).
     * @param {boolean} [isJourneyInFreeTramZone] 
     * @param {Array<0 | 1 | 2 | 3 | 4>} [travelledRouteTypes] 
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FareEstimateApi
     */
    public fareEstimateGetFareEstimateByZone(minZone: number, maxZone: number, journeyTouchOnUtc?: Date, journeyTouchOffUtc?: Date, isJourneyInFreeTramZone?: boolean, travelledRouteTypes?: Array<0 | 1 | 2 | 3 | 4>, token?: string, devid?: string, signature?: string, options?: any) {
        return FareEstimateApiFp(this.configuration).fareEstimateGetFareEstimateByZone(minZone, maxZone, journeyTouchOnUtc, journeyTouchOffUtc, isJourneyInFreeTramZone, travelledRouteTypes, token, devid, signature, options)(this.fetch, this.basePath);
    }

}

/**
 * OutletsApi - fetch parameter creator
 * @export
 */
export const OutletsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all ticket outlets
         * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outletsGetAllOutlets(maxResults?: number, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/outlets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List ticket outlets near a specific location
         * @param {number} latitude Geographic coordinate of latitude
         * @param {number} longitude Geographic coordinate of longitude
         * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters (default &#x3D; 300)
         * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outletsGetOutletsByGeolocation(latitude: number, longitude: number, maxDistance?: number, maxResults?: number, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'latitude' is not null or undefined
            if (latitude === null || latitude === undefined) {
                throw new RequiredError('latitude','Required parameter latitude was null or undefined when calling outletsGetOutletsByGeolocation.');
            }
            // verify required parameter 'longitude' is not null or undefined
            if (longitude === null || longitude === undefined) {
                throw new RequiredError('longitude','Required parameter longitude was null or undefined when calling outletsGetOutletsByGeolocation.');
            }
            const localVarPath = `/v3/outlets/location/{latitude},{longitude}`
                .replace(`{${"latitude"}}`, encodeURIComponent(String(latitude)))
                .replace(`{${"longitude"}}`, encodeURIComponent(String(longitude)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxDistance !== undefined) {
                localVarQueryParameter['max_distance'] = maxDistance;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OutletsApi - functional programming interface
 * @export
 */
export const OutletsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all ticket outlets
         * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outletsGetAllOutlets(maxResults?: number, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3OutletResponse> {
            const localVarFetchArgs = OutletsApiFetchParamCreator(configuration).outletsGetAllOutlets(maxResults, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List ticket outlets near a specific location
         * @param {number} latitude Geographic coordinate of latitude
         * @param {number} longitude Geographic coordinate of longitude
         * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters (default &#x3D; 300)
         * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outletsGetOutletsByGeolocation(latitude: number, longitude: number, maxDistance?: number, maxResults?: number, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3OutletGeolocationResponse> {
            const localVarFetchArgs = OutletsApiFetchParamCreator(configuration).outletsGetOutletsByGeolocation(latitude, longitude, maxDistance, maxResults, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OutletsApi - factory interface
 * @export
 */
export const OutletsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List all ticket outlets
         * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outletsGetAllOutlets(maxResults?: number, token?: string, devid?: string, signature?: string, options?: any) {
            return OutletsApiFp(configuration).outletsGetAllOutlets(maxResults, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List ticket outlets near a specific location
         * @param {number} latitude Geographic coordinate of latitude
         * @param {number} longitude Geographic coordinate of longitude
         * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters (default &#x3D; 300)
         * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outletsGetOutletsByGeolocation(latitude: number, longitude: number, maxDistance?: number, maxResults?: number, token?: string, devid?: string, signature?: string, options?: any) {
            return OutletsApiFp(configuration).outletsGetOutletsByGeolocation(latitude, longitude, maxDistance, maxResults, token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * OutletsApi - object-oriented interface
 * @export
 * @class OutletsApi
 * @extends {BaseAPI}
 */
export class OutletsApi extends BaseAPI {
    /**
     * 
     * @summary List all ticket outlets
     * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutletsApi
     */
    public outletsGetAllOutlets(maxResults?: number, token?: string, devid?: string, signature?: string, options?: any) {
        return OutletsApiFp(this.configuration).outletsGetAllOutlets(maxResults, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List ticket outlets near a specific location
     * @param {number} latitude Geographic coordinate of latitude
     * @param {number} longitude Geographic coordinate of longitude
     * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters (default &#x3D; 300)
     * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutletsApi
     */
    public outletsGetOutletsByGeolocation(latitude: number, longitude: number, maxDistance?: number, maxResults?: number, token?: string, devid?: string, signature?: string, options?: any) {
        return OutletsApiFp(this.configuration).outletsGetOutletsByGeolocation(latitude, longitude, maxDistance, maxResults, token, devid, signature, options)(this.fetch, this.basePath);
    }

}

/**
 * PatternsApi - fetch parameter creator
 * @export
 */
export const PatternsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View the stopping pattern for a specific trip/service run
         * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor and None. Default is Disruption. Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
         * @param {number} [stopId] Filter by stop_id; values returned by Stops API
         * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format)
         * @param {boolean} [includeSkippedStops] Include any skipped stops in a stopping pattern. Defaults to false.
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patternsGetPatternByRun(runRef: string, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, stopId?: number, dateUtc?: Date, includeSkippedStops?: boolean, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runRef' is not null or undefined
            if (runRef === null || runRef === undefined) {
                throw new RequiredError('runRef','Required parameter runRef was null or undefined when calling patternsGetPatternByRun.');
            }
            // verify required parameter 'routeType' is not null or undefined
            if (routeType === null || routeType === undefined) {
                throw new RequiredError('routeType','Required parameter routeType was null or undefined when calling patternsGetPatternByRun.');
            }
            // verify required parameter 'expand' is not null or undefined
            if (expand === null || expand === undefined) {
                throw new RequiredError('expand','Required parameter expand was null or undefined when calling patternsGetPatternByRun.');
            }
            const localVarPath = `/v3/pattern/run/{run_ref}/route_type/{route_type}`
                .replace(`{${"run_ref"}}`, encodeURIComponent(String(runRef)))
                .replace(`{${"route_type"}}`, encodeURIComponent(String(routeType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (stopId !== undefined) {
                localVarQueryParameter['stop_id'] = stopId;
            }

            if (dateUtc !== undefined) {
                localVarQueryParameter['date_utc'] = (dateUtc as any).toISOString();
            }

            if (includeSkippedStops !== undefined) {
                localVarQueryParameter['include_skipped_stops'] = includeSkippedStops;
            }

            if (includeGeopath !== undefined) {
                localVarQueryParameter['include_geopath'] = includeGeopath;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatternsApi - functional programming interface
 * @export
 */
export const PatternsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View the stopping pattern for a specific trip/service run
         * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor and None. Default is Disruption. Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
         * @param {number} [stopId] Filter by stop_id; values returned by Stops API
         * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format)
         * @param {boolean} [includeSkippedStops] Include any skipped stops in a stopping pattern. Defaults to false.
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patternsGetPatternByRun(runRef: string, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, stopId?: number, dateUtc?: Date, includeSkippedStops?: boolean, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3StoppingPattern> {
            const localVarFetchArgs = PatternsApiFetchParamCreator(configuration).patternsGetPatternByRun(runRef, routeType, expand, stopId, dateUtc, includeSkippedStops, includeGeopath, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PatternsApi - factory interface
 * @export
 */
export const PatternsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary View the stopping pattern for a specific trip/service run
         * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor and None. Default is Disruption. Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
         * @param {number} [stopId] Filter by stop_id; values returned by Stops API
         * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format)
         * @param {boolean} [includeSkippedStops] Include any skipped stops in a stopping pattern. Defaults to false.
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patternsGetPatternByRun(runRef: string, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, stopId?: number, dateUtc?: Date, includeSkippedStops?: boolean, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
            return PatternsApiFp(configuration).patternsGetPatternByRun(runRef, routeType, expand, stopId, dateUtc, includeSkippedStops, includeGeopath, token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * PatternsApi - object-oriented interface
 * @export
 * @class PatternsApi
 * @extends {BaseAPI}
 */
export class PatternsApi extends BaseAPI {
    /**
     * 
     * @summary View the stopping pattern for a specific trip/service run
     * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
     * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
     * @param {Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor and None. Default is Disruption. Run must be expanded to receive VehiclePosition and VehicleDescriptor information.
     * @param {number} [stopId] Filter by stop_id; values returned by Stops API
     * @param {Date} [dateUtc] Filter by the date and time of the request (ISO 8601 UTC format)
     * @param {boolean} [includeSkippedStops] Include any skipped stops in a stopping pattern. Defaults to false.
     * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatternsApi
     */
    public patternsGetPatternByRun(runRef: string, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'Stop' | 'Route' | 'Run' | 'Direction' | 'Disruption' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, stopId?: number, dateUtc?: Date, includeSkippedStops?: boolean, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
        return PatternsApiFp(this.configuration).patternsGetPatternByRun(runRef, routeType, expand, stopId, dateUtc, includeSkippedStops, includeGeopath, token, devid, signature, options)(this.fetch, this.basePath);
    }

}

/**
 * RouteTypesApi - fetch parameter creator
 * @export
 */
export const RouteTypesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View all route types and their names
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeTypesGetRouteTypes(token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/route_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RouteTypesApi - functional programming interface
 * @export
 */
export const RouteTypesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View all route types and their names
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeTypesGetRouteTypes(token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3RouteTypesResponse> {
            const localVarFetchArgs = RouteTypesApiFetchParamCreator(configuration).routeTypesGetRouteTypes(token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RouteTypesApi - factory interface
 * @export
 */
export const RouteTypesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary View all route types and their names
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeTypesGetRouteTypes(token?: string, devid?: string, signature?: string, options?: any) {
            return RouteTypesApiFp(configuration).routeTypesGetRouteTypes(token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * RouteTypesApi - object-oriented interface
 * @export
 * @class RouteTypesApi
 * @extends {BaseAPI}
 */
export class RouteTypesApi extends BaseAPI {
    /**
     * 
     * @summary View all route types and their names
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteTypesApi
     */
    public routeTypesGetRouteTypes(token?: string, devid?: string, signature?: string, options?: any) {
        return RouteTypesApiFp(this.configuration).routeTypesGetRouteTypes(token, devid, signature, options)(this.fetch, this.basePath);
    }

}

/**
 * RoutesApi - fetch parameter creator
 * @export
 */
export const RoutesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View route names and numbers for all routes
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
         * @param {string} [routeName] Filter by name  of route (accepts partial route name matches)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routesOneOrMoreRoutes(routeTypes?: Array<0 | 1 | 2 | 3 | 4>, routeName?: string, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/routes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (routeTypes) {
                localVarQueryParameter['route_types'] = routeTypes;
            }

            if (routeName !== undefined) {
                localVarQueryParameter['route_name'] = routeName;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View route name and number for specific route ID
         * @param {number} routeId Identifier of route; values returned by Departures, Directions and Disruptions APIs
         * @param {boolean} [includeGeopath] Indicates kif geopath data will be returned (default &#x3D; false)
         * @param {Date} [geopathUtc] Filter geopaths by date (ISO 8601 UTC format) (default &#x3D; current date)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routesRouteFromId(routeId: number, includeGeopath?: boolean, geopathUtc?: Date, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling routesRouteFromId.');
            }
            const localVarPath = `/v3/routes/{route_id}`
                .replace(`{${"route_id"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeGeopath !== undefined) {
                localVarQueryParameter['include_geopath'] = includeGeopath;
            }

            if (geopathUtc !== undefined) {
                localVarQueryParameter['geopath_utc'] = (geopathUtc as any).toISOString();
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutesApi - functional programming interface
 * @export
 */
export const RoutesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View route names and numbers for all routes
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
         * @param {string} [routeName] Filter by name  of route (accepts partial route name matches)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routesOneOrMoreRoutes(routeTypes?: Array<0 | 1 | 2 | 3 | 4>, routeName?: string, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3RouteResponse> {
            const localVarFetchArgs = RoutesApiFetchParamCreator(configuration).routesOneOrMoreRoutes(routeTypes, routeName, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View route name and number for specific route ID
         * @param {number} routeId Identifier of route; values returned by Departures, Directions and Disruptions APIs
         * @param {boolean} [includeGeopath] Indicates kif geopath data will be returned (default &#x3D; false)
         * @param {Date} [geopathUtc] Filter geopaths by date (ISO 8601 UTC format) (default &#x3D; current date)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routesRouteFromId(routeId: number, includeGeopath?: boolean, geopathUtc?: Date, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3RouteResponse> {
            const localVarFetchArgs = RoutesApiFetchParamCreator(configuration).routesRouteFromId(routeId, includeGeopath, geopathUtc, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RoutesApi - factory interface
 * @export
 */
export const RoutesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary View route names and numbers for all routes
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
         * @param {string} [routeName] Filter by name  of route (accepts partial route name matches)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routesOneOrMoreRoutes(routeTypes?: Array<0 | 1 | 2 | 3 | 4>, routeName?: string, token?: string, devid?: string, signature?: string, options?: any) {
            return RoutesApiFp(configuration).routesOneOrMoreRoutes(routeTypes, routeName, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View route name and number for specific route ID
         * @param {number} routeId Identifier of route; values returned by Departures, Directions and Disruptions APIs
         * @param {boolean} [includeGeopath] Indicates kif geopath data will be returned (default &#x3D; false)
         * @param {Date} [geopathUtc] Filter geopaths by date (ISO 8601 UTC format) (default &#x3D; current date)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routesRouteFromId(routeId: number, includeGeopath?: boolean, geopathUtc?: Date, token?: string, devid?: string, signature?: string, options?: any) {
            return RoutesApiFp(configuration).routesRouteFromId(routeId, includeGeopath, geopathUtc, token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * RoutesApi - object-oriented interface
 * @export
 * @class RoutesApi
 * @extends {BaseAPI}
 */
export class RoutesApi extends BaseAPI {
    /**
     * 
     * @summary View route names and numbers for all routes
     * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
     * @param {string} [routeName] Filter by name  of route (accepts partial route name matches)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public routesOneOrMoreRoutes(routeTypes?: Array<0 | 1 | 2 | 3 | 4>, routeName?: string, token?: string, devid?: string, signature?: string, options?: any) {
        return RoutesApiFp(this.configuration).routesOneOrMoreRoutes(routeTypes, routeName, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View route name and number for specific route ID
     * @param {number} routeId Identifier of route; values returned by Departures, Directions and Disruptions APIs
     * @param {boolean} [includeGeopath] Indicates kif geopath data will be returned (default &#x3D; false)
     * @param {Date} [geopathUtc] Filter geopaths by date (ISO 8601 UTC format) (default &#x3D; current date)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public routesRouteFromId(routeId: number, includeGeopath?: boolean, geopathUtc?: Date, token?: string, devid?: string, signature?: string, options?: any) {
        return RoutesApiFp(this.configuration).routesRouteFromId(routeId, includeGeopath, geopathUtc, token, devid, signature, options)(this.fetch, this.basePath);
    }

}

/**
 * RunsApi - fetch parameter creator
 * @export
 */
export const RunsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View all trip/service runs for a specific route ID
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes.
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRoute(routeId: number, expand?: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling runsForRoute.');
            }
            const localVarPath = `/v3/runs/route/{route_id}`
                .replace(`{${"route_id"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (dateUtc !== undefined) {
                localVarQueryParameter['date_utc'] = (dateUtc as any).toISOString();
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View all trip/service runs for a specific route ID and route type
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes.
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is All.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRouteAndRouteType(routeId: number, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling runsForRouteAndRouteType.');
            }
            // verify required parameter 'routeType' is not null or undefined
            if (routeType === null || routeType === undefined) {
                throw new RequiredError('routeType','Required parameter routeType was null or undefined when calling runsForRouteAndRouteType.');
            }
            // verify required parameter 'expand' is not null or undefined
            if (expand === null || expand === undefined) {
                throw new RequiredError('expand','Required parameter expand was null or undefined when calling runsForRouteAndRouteType.');
            }
            const localVarPath = `/v3/runs/route/{route_id}/route_type/{route_type}`
                .replace(`{${"route_id"}}`, encodeURIComponent(String(routeId)))
                .replace(`{${"route_type"}}`, encodeURIComponent(String(routeType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (dateUtc !== undefined) {
                localVarQueryParameter['date_utc'] = (dateUtc as any).toISOString();
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View all trip/service runs for a specific run_ref
         * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRun(runRef: string, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runRef' is not null or undefined
            if (runRef === null || runRef === undefined) {
                throw new RequiredError('runRef','Required parameter runRef was null or undefined when calling runsForRun.');
            }
            // verify required parameter 'expand' is not null or undefined
            if (expand === null || expand === undefined) {
                throw new RequiredError('expand','Required parameter expand was null or undefined when calling runsForRun.');
            }
            const localVarPath = `/v3/runs/{run_ref}`
                .replace(`{${"run_ref"}}`, encodeURIComponent(String(runRef)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (dateUtc !== undefined) {
                localVarQueryParameter['date_utc'] = (dateUtc as any).toISOString();
            }

            if (includeGeopath !== undefined) {
                localVarQueryParameter['include_geopath'] = includeGeopath;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View the trip/service run for a specific run_ref and route type
         * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRunAndRouteType(runRef: string, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runRef' is not null or undefined
            if (runRef === null || runRef === undefined) {
                throw new RequiredError('runRef','Required parameter runRef was null or undefined when calling runsForRunAndRouteType.');
            }
            // verify required parameter 'routeType' is not null or undefined
            if (routeType === null || routeType === undefined) {
                throw new RequiredError('routeType','Required parameter routeType was null or undefined when calling runsForRunAndRouteType.');
            }
            // verify required parameter 'expand' is not null or undefined
            if (expand === null || expand === undefined) {
                throw new RequiredError('expand','Required parameter expand was null or undefined when calling runsForRunAndRouteType.');
            }
            const localVarPath = `/v3/runs/{run_ref}/route_type/{route_type}`
                .replace(`{${"run_ref"}}`, encodeURIComponent(String(runRef)))
                .replace(`{${"route_type"}}`, encodeURIComponent(String(routeType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (dateUtc !== undefined) {
                localVarQueryParameter['date_utc'] = (dateUtc as any).toISOString();
            }

            if (includeGeopath !== undefined) {
                localVarQueryParameter['include_geopath'] = includeGeopath;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsApi - functional programming interface
 * @export
 */
export const RunsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View all trip/service runs for a specific route ID
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes.
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRoute(routeId: number, expand?: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3RunsResponse> {
            const localVarFetchArgs = RunsApiFetchParamCreator(configuration).runsForRoute(routeId, expand, dateUtc, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View all trip/service runs for a specific route ID and route type
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes.
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is All.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRouteAndRouteType(routeId: number, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3RunsResponse> {
            const localVarFetchArgs = RunsApiFetchParamCreator(configuration).runsForRouteAndRouteType(routeId, routeType, expand, dateUtc, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View all trip/service runs for a specific run_ref
         * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRun(runRef: string, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3RunsResponse> {
            const localVarFetchArgs = RunsApiFetchParamCreator(configuration).runsForRun(runRef, expand, dateUtc, includeGeopath, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View the trip/service run for a specific run_ref and route type
         * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRunAndRouteType(runRef: string, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3RunResponse> {
            const localVarFetchArgs = RunsApiFetchParamCreator(configuration).runsForRunAndRouteType(runRef, routeType, expand, dateUtc, includeGeopath, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunsApi - factory interface
 * @export
 */
export const RunsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary View all trip/service runs for a specific route ID
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes.
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRoute(routeId: number, expand?: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, token?: string, devid?: string, signature?: string, options?: any) {
            return RunsApiFp(configuration).runsForRoute(routeId, expand, dateUtc, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View all trip/service runs for a specific route ID and route type
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes.
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is All.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRouteAndRouteType(routeId: number, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, token?: string, devid?: string, signature?: string, options?: any) {
            return RunsApiFp(configuration).runsForRouteAndRouteType(routeId, routeType, expand, dateUtc, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View all trip/service runs for a specific run_ref
         * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRun(runRef: string, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
            return RunsApiFp(configuration).runsForRun(runRef, expand, dateUtc, includeGeopath, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View the trip/service run for a specific run_ref and route type
         * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
         * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsForRunAndRouteType(runRef: string, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
            return RunsApiFp(configuration).runsForRunAndRouteType(runRef, routeType, expand, dateUtc, includeGeopath, token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * RunsApi - object-oriented interface
 * @export
 * @class RunsApi
 * @extends {BaseAPI}
 */
export class RunsApi extends BaseAPI {
    /**
     * 
     * @summary View all trip/service runs for a specific route ID
     * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes.
     * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} [expand] List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
     * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public runsForRoute(routeId: number, expand?: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, token?: string, devid?: string, signature?: string, options?: any) {
        return RunsApiFp(this.configuration).runsForRoute(routeId, expand, dateUtc, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View all trip/service runs for a specific route ID and route type
     * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes.
     * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
     * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is All.
     * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public runsForRouteAndRouteType(routeId: number, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, token?: string, devid?: string, signature?: string, options?: any) {
        return RunsApiFp(this.configuration).runsForRouteAndRouteType(routeId, routeType, expand, dateUtc, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View all trip/service runs for a specific run_ref
     * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
     * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
     * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
     * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public runsForRun(runRef: string, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
        return RunsApiFp(this.configuration).runsForRun(runRef, expand, dateUtc, includeGeopath, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View the trip/service run for a specific run_ref and route type
     * @param {string} runRef The run_ref is the identifier of a run as returned by the departures/_* and runs/_* endpoints. WARNING, run_id is deprecated. Use run_ref instead.
     * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
     * @param {Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>} expand List of objects to be returned in full (i.e. expanded) - options include: All, VehiclePosition, VehicleDescriptor, or None. Default is None.
     * @param {Date} [dateUtc] Date of the request. (optional - defaults to now)
     * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public runsForRunAndRouteType(runRef: string, routeType: 0 | 1 | 2 | 3 | 4, expand: Array<'All' | 'VehicleDescriptor' | 'VehiclePosition' | 'None'>, dateUtc?: Date, includeGeopath?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
        return RunsApiFp(this.configuration).runsForRunAndRouteType(runRef, routeType, expand, dateUtc, includeGeopath, token, devid, signature, options)(this.fetch, this.basePath);
    }

}

/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View stops, routes and myki ticket outlets that match the search term
         * @param {string} searchTerm Search text (note: if search text is numeric and/or less than 3 characters, the API will only return routes)
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API (note: stops and routes are ordered by route_types specified)
         * @param {number} [latitude] Filter by geographic coordinate of latitude
         * @param {number} [longitude] Filter by geographic coordinate of longitude
         * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters
         * @param {boolean} [includeAddresses] Placeholder for future development; currently unavailable
         * @param {boolean} [includeOutlets] Indicates if outlets will be returned in response (default &#x3D; true)
         * @param {boolean} [matchStopBySuburb] Indicates whether to find stops by suburbs in the search term (default &#x3D; true)
         * @param {boolean} [matchRouteBySuburb] Indicates whether to find routes by suburbs in the search term (default &#x3D; true)
         * @param {boolean} [matchStopByGtfsStopId] Indicates whether to search for stops according to a metlink stop ID (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSearch(searchTerm: string, routeTypes?: Array<0 | 1 | 2 | 3 | 4>, latitude?: number, longitude?: number, maxDistance?: number, includeAddresses?: boolean, includeOutlets?: boolean, matchStopBySuburb?: boolean, matchRouteBySuburb?: boolean, matchStopByGtfsStopId?: boolean, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'searchTerm' is not null or undefined
            if (searchTerm === null || searchTerm === undefined) {
                throw new RequiredError('searchTerm','Required parameter searchTerm was null or undefined when calling searchSearch.');
            }
            const localVarPath = `/v3/search/{search_term}`
                .replace(`{${"search_term"}}`, encodeURIComponent(String(searchTerm)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (routeTypes) {
                localVarQueryParameter['route_types'] = routeTypes;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (maxDistance !== undefined) {
                localVarQueryParameter['max_distance'] = maxDistance;
            }

            if (includeAddresses !== undefined) {
                localVarQueryParameter['include_addresses'] = includeAddresses;
            }

            if (includeOutlets !== undefined) {
                localVarQueryParameter['include_outlets'] = includeOutlets;
            }

            if (matchStopBySuburb !== undefined) {
                localVarQueryParameter['match_stop_by_suburb'] = matchStopBySuburb;
            }

            if (matchRouteBySuburb !== undefined) {
                localVarQueryParameter['match_route_by_suburb'] = matchRouteBySuburb;
            }

            if (matchStopByGtfsStopId !== undefined) {
                localVarQueryParameter['match_stop_by_gtfs_stop_id'] = matchStopByGtfsStopId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View stops, routes and myki ticket outlets that match the search term
         * @param {string} searchTerm Search text (note: if search text is numeric and/or less than 3 characters, the API will only return routes)
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API (note: stops and routes are ordered by route_types specified)
         * @param {number} [latitude] Filter by geographic coordinate of latitude
         * @param {number} [longitude] Filter by geographic coordinate of longitude
         * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters
         * @param {boolean} [includeAddresses] Placeholder for future development; currently unavailable
         * @param {boolean} [includeOutlets] Indicates if outlets will be returned in response (default &#x3D; true)
         * @param {boolean} [matchStopBySuburb] Indicates whether to find stops by suburbs in the search term (default &#x3D; true)
         * @param {boolean} [matchRouteBySuburb] Indicates whether to find routes by suburbs in the search term (default &#x3D; true)
         * @param {boolean} [matchStopByGtfsStopId] Indicates whether to search for stops according to a metlink stop ID (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSearch(searchTerm: string, routeTypes?: Array<0 | 1 | 2 | 3 | 4>, latitude?: number, longitude?: number, maxDistance?: number, includeAddresses?: boolean, includeOutlets?: boolean, matchStopBySuburb?: boolean, matchRouteBySuburb?: boolean, matchStopByGtfsStopId?: boolean, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3SearchResult> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).searchSearch(searchTerm, routeTypes, latitude, longitude, maxDistance, includeAddresses, includeOutlets, matchStopBySuburb, matchRouteBySuburb, matchStopByGtfsStopId, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary View stops, routes and myki ticket outlets that match the search term
         * @param {string} searchTerm Search text (note: if search text is numeric and/or less than 3 characters, the API will only return routes)
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API (note: stops and routes are ordered by route_types specified)
         * @param {number} [latitude] Filter by geographic coordinate of latitude
         * @param {number} [longitude] Filter by geographic coordinate of longitude
         * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters
         * @param {boolean} [includeAddresses] Placeholder for future development; currently unavailable
         * @param {boolean} [includeOutlets] Indicates if outlets will be returned in response (default &#x3D; true)
         * @param {boolean} [matchStopBySuburb] Indicates whether to find stops by suburbs in the search term (default &#x3D; true)
         * @param {boolean} [matchRouteBySuburb] Indicates whether to find routes by suburbs in the search term (default &#x3D; true)
         * @param {boolean} [matchStopByGtfsStopId] Indicates whether to search for stops according to a metlink stop ID (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSearch(searchTerm: string, routeTypes?: Array<0 | 1 | 2 | 3 | 4>, latitude?: number, longitude?: number, maxDistance?: number, includeAddresses?: boolean, includeOutlets?: boolean, matchStopBySuburb?: boolean, matchRouteBySuburb?: boolean, matchStopByGtfsStopId?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
            return SearchApiFp(configuration).searchSearch(searchTerm, routeTypes, latitude, longitude, maxDistance, includeAddresses, includeOutlets, matchStopBySuburb, matchRouteBySuburb, matchStopByGtfsStopId, token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @summary View stops, routes and myki ticket outlets that match the search term
     * @param {string} searchTerm Search text (note: if search text is numeric and/or less than 3 characters, the API will only return routes)
     * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API (note: stops and routes are ordered by route_types specified)
     * @param {number} [latitude] Filter by geographic coordinate of latitude
     * @param {number} [longitude] Filter by geographic coordinate of longitude
     * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters
     * @param {boolean} [includeAddresses] Placeholder for future development; currently unavailable
     * @param {boolean} [includeOutlets] Indicates if outlets will be returned in response (default &#x3D; true)
     * @param {boolean} [matchStopBySuburb] Indicates whether to find stops by suburbs in the search term (default &#x3D; true)
     * @param {boolean} [matchRouteBySuburb] Indicates whether to find routes by suburbs in the search term (default &#x3D; true)
     * @param {boolean} [matchStopByGtfsStopId] Indicates whether to search for stops according to a metlink stop ID (default &#x3D; false)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchSearch(searchTerm: string, routeTypes?: Array<0 | 1 | 2 | 3 | 4>, latitude?: number, longitude?: number, maxDistance?: number, includeAddresses?: boolean, includeOutlets?: boolean, matchStopBySuburb?: boolean, matchRouteBySuburb?: boolean, matchStopByGtfsStopId?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
        return SearchApiFp(this.configuration).searchSearch(searchTerm, routeTypes, latitude, longitude, maxDistance, includeAddresses, includeOutlets, matchStopBySuburb, matchRouteBySuburb, matchStopByGtfsStopId, token, devid, signature, options)(this.fetch, this.basePath);
    }

}

/**
 * StopsApi - fetch parameter creator
 * @export
 */
export const StopsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View facilities at a specific stop (Metro and V/Line stations only)
         * @param {number} stopId Identifier of stop; values returned by Stops API
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {boolean} [stopLocation] Indicates if stop location information will be returned (default &#x3D; false)
         * @param {boolean} [stopAmenities] Indicates if stop amenity information will be returned (default &#x3D; false)
         * @param {boolean} [stopAccessibility] Indicates if stop accessibility information will be returned (default &#x3D; false)
         * @param {boolean} [stopContact] Indicates if stop contact information will be returned (default &#x3D; false)
         * @param {boolean} [stopTicket] Indicates if stop ticket information will be returned (default &#x3D; false)
         * @param {boolean} [gtfs] Incdicates whether the stop_id is a GTFS ID or not
         * @param {boolean} [stopStaffing] Indicates if stop staffing information will be returned (default &#x3D; false)
         * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopsStopDetails(stopId: number, routeType: 0 | 1 | 2 | 3 | 4, stopLocation?: boolean, stopAmenities?: boolean, stopAccessibility?: boolean, stopContact?: boolean, stopTicket?: boolean, gtfs?: boolean, stopStaffing?: boolean, stopDisruptions?: boolean, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'stopId' is not null or undefined
            if (stopId === null || stopId === undefined) {
                throw new RequiredError('stopId','Required parameter stopId was null or undefined when calling stopsStopDetails.');
            }
            // verify required parameter 'routeType' is not null or undefined
            if (routeType === null || routeType === undefined) {
                throw new RequiredError('routeType','Required parameter routeType was null or undefined when calling stopsStopDetails.');
            }
            const localVarPath = `/v3/stops/{stop_id}/route_type/{route_type}`
                .replace(`{${"stop_id"}}`, encodeURIComponent(String(stopId)))
                .replace(`{${"route_type"}}`, encodeURIComponent(String(routeType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stopLocation !== undefined) {
                localVarQueryParameter['stop_location'] = stopLocation;
            }

            if (stopAmenities !== undefined) {
                localVarQueryParameter['stop_amenities'] = stopAmenities;
            }

            if (stopAccessibility !== undefined) {
                localVarQueryParameter['stop_accessibility'] = stopAccessibility;
            }

            if (stopContact !== undefined) {
                localVarQueryParameter['stop_contact'] = stopContact;
            }

            if (stopTicket !== undefined) {
                localVarQueryParameter['stop_ticket'] = stopTicket;
            }

            if (gtfs !== undefined) {
                localVarQueryParameter['gtfs'] = gtfs;
            }

            if (stopStaffing !== undefined) {
                localVarQueryParameter['stop_staffing'] = stopStaffing;
            }

            if (stopDisruptions !== undefined) {
                localVarQueryParameter['stop_disruptions'] = stopDisruptions;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View all stops near a specific location
         * @param {number} latitude Geographic coordinate of latitude
         * @param {number} longitude Geographic coordinate of longitude
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
         * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
         * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters (default &#x3D; 300)
         * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopsStopsByGeolocation(latitude: number, longitude: number, routeTypes?: Array<0 | 1 | 2 | 3 | 4>, maxResults?: number, maxDistance?: number, stopDisruptions?: boolean, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'latitude' is not null or undefined
            if (latitude === null || latitude === undefined) {
                throw new RequiredError('latitude','Required parameter latitude was null or undefined when calling stopsStopsByGeolocation.');
            }
            // verify required parameter 'longitude' is not null or undefined
            if (longitude === null || longitude === undefined) {
                throw new RequiredError('longitude','Required parameter longitude was null or undefined when calling stopsStopsByGeolocation.');
            }
            const localVarPath = `/v3/stops/location/{latitude},{longitude}`
                .replace(`{${"latitude"}}`, encodeURIComponent(String(latitude)))
                .replace(`{${"longitude"}}`, encodeURIComponent(String(longitude)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (routeTypes) {
                localVarQueryParameter['route_types'] = routeTypes;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (maxDistance !== undefined) {
                localVarQueryParameter['max_distance'] = maxDistance;
            }

            if (stopDisruptions !== undefined) {
                localVarQueryParameter['stop_disruptions'] = stopDisruptions;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View all stops on a specific route
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {number} [directionId] An optional direction; values returned by Directions API. When this is set, stop sequence information is returned in the response.
         * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {Date} [geopathUtc] Filter geopaths by date (ISO 8601 UTC format) (default &#x3D; current date)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopsStopsForRoute(routeId: number, routeType: 0 | 1 | 2 | 3 | 4, directionId?: number, stopDisruptions?: boolean, includeGeopath?: boolean, geopathUtc?: Date, token?: string, devid?: string, signature?: string, options: any = {}): FetchArgs {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling stopsStopsForRoute.');
            }
            // verify required parameter 'routeType' is not null or undefined
            if (routeType === null || routeType === undefined) {
                throw new RequiredError('routeType','Required parameter routeType was null or undefined when calling stopsStopsForRoute.');
            }
            const localVarPath = `/v3/stops/route/{route_id}/route_type/{route_type}`
                .replace(`{${"route_id"}}`, encodeURIComponent(String(routeId)))
                .replace(`{${"route_type"}}`, encodeURIComponent(String(routeType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (directionId !== undefined) {
                localVarQueryParameter['direction_id'] = directionId;
            }

            if (stopDisruptions !== undefined) {
                localVarQueryParameter['stop_disruptions'] = stopDisruptions;
            }

            if (includeGeopath !== undefined) {
                localVarQueryParameter['include_geopath'] = includeGeopath;
            }

            if (geopathUtc !== undefined) {
                localVarQueryParameter['geopath_utc'] = (geopathUtc as any).toISOString();
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (devid !== undefined) {
                localVarQueryParameter['devid'] = devid;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StopsApi - functional programming interface
 * @export
 */
export const StopsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary View facilities at a specific stop (Metro and V/Line stations only)
         * @param {number} stopId Identifier of stop; values returned by Stops API
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {boolean} [stopLocation] Indicates if stop location information will be returned (default &#x3D; false)
         * @param {boolean} [stopAmenities] Indicates if stop amenity information will be returned (default &#x3D; false)
         * @param {boolean} [stopAccessibility] Indicates if stop accessibility information will be returned (default &#x3D; false)
         * @param {boolean} [stopContact] Indicates if stop contact information will be returned (default &#x3D; false)
         * @param {boolean} [stopTicket] Indicates if stop ticket information will be returned (default &#x3D; false)
         * @param {boolean} [gtfs] Incdicates whether the stop_id is a GTFS ID or not
         * @param {boolean} [stopStaffing] Indicates if stop staffing information will be returned (default &#x3D; false)
         * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopsStopDetails(stopId: number, routeType: 0 | 1 | 2 | 3 | 4, stopLocation?: boolean, stopAmenities?: boolean, stopAccessibility?: boolean, stopContact?: boolean, stopTicket?: boolean, gtfs?: boolean, stopStaffing?: boolean, stopDisruptions?: boolean, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3StopResponse> {
            const localVarFetchArgs = StopsApiFetchParamCreator(configuration).stopsStopDetails(stopId, routeType, stopLocation, stopAmenities, stopAccessibility, stopContact, stopTicket, gtfs, stopStaffing, stopDisruptions, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View all stops near a specific location
         * @param {number} latitude Geographic coordinate of latitude
         * @param {number} longitude Geographic coordinate of longitude
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
         * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
         * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters (default &#x3D; 300)
         * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopsStopsByGeolocation(latitude: number, longitude: number, routeTypes?: Array<0 | 1 | 2 | 3 | 4>, maxResults?: number, maxDistance?: number, stopDisruptions?: boolean, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3StopsByDistanceResponse> {
            const localVarFetchArgs = StopsApiFetchParamCreator(configuration).stopsStopsByGeolocation(latitude, longitude, routeTypes, maxResults, maxDistance, stopDisruptions, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View all stops on a specific route
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {number} [directionId] An optional direction; values returned by Directions API. When this is set, stop sequence information is returned in the response.
         * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {Date} [geopathUtc] Filter geopaths by date (ISO 8601 UTC format) (default &#x3D; current date)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopsStopsForRoute(routeId: number, routeType: 0 | 1 | 2 | 3 | 4, directionId?: number, stopDisruptions?: boolean, includeGeopath?: boolean, geopathUtc?: Date, token?: string, devid?: string, signature?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3StopsOnRouteResponse> {
            const localVarFetchArgs = StopsApiFetchParamCreator(configuration).stopsStopsForRoute(routeId, routeType, directionId, stopDisruptions, includeGeopath, geopathUtc, token, devid, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StopsApi - factory interface
 * @export
 */
export const StopsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary View facilities at a specific stop (Metro and V/Line stations only)
         * @param {number} stopId Identifier of stop; values returned by Stops API
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {boolean} [stopLocation] Indicates if stop location information will be returned (default &#x3D; false)
         * @param {boolean} [stopAmenities] Indicates if stop amenity information will be returned (default &#x3D; false)
         * @param {boolean} [stopAccessibility] Indicates if stop accessibility information will be returned (default &#x3D; false)
         * @param {boolean} [stopContact] Indicates if stop contact information will be returned (default &#x3D; false)
         * @param {boolean} [stopTicket] Indicates if stop ticket information will be returned (default &#x3D; false)
         * @param {boolean} [gtfs] Incdicates whether the stop_id is a GTFS ID or not
         * @param {boolean} [stopStaffing] Indicates if stop staffing information will be returned (default &#x3D; false)
         * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopsStopDetails(stopId: number, routeType: 0 | 1 | 2 | 3 | 4, stopLocation?: boolean, stopAmenities?: boolean, stopAccessibility?: boolean, stopContact?: boolean, stopTicket?: boolean, gtfs?: boolean, stopStaffing?: boolean, stopDisruptions?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
            return StopsApiFp(configuration).stopsStopDetails(stopId, routeType, stopLocation, stopAmenities, stopAccessibility, stopContact, stopTicket, gtfs, stopStaffing, stopDisruptions, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View all stops near a specific location
         * @param {number} latitude Geographic coordinate of latitude
         * @param {number} longitude Geographic coordinate of longitude
         * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
         * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
         * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters (default &#x3D; 300)
         * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopsStopsByGeolocation(latitude: number, longitude: number, routeTypes?: Array<0 | 1 | 2 | 3 | 4>, maxResults?: number, maxDistance?: number, stopDisruptions?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
            return StopsApiFp(configuration).stopsStopsByGeolocation(latitude, longitude, routeTypes, maxResults, maxDistance, stopDisruptions, token, devid, signature, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View all stops on a specific route
         * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
         * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
         * @param {number} [directionId] An optional direction; values returned by Directions API. When this is set, stop sequence information is returned in the response.
         * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
         * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
         * @param {Date} [geopathUtc] Filter geopaths by date (ISO 8601 UTC format) (default &#x3D; current date)
         * @param {string} [token] Please ignore
         * @param {string} [devid] Your developer id
         * @param {string} [signature] Authentication signature for request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopsStopsForRoute(routeId: number, routeType: 0 | 1 | 2 | 3 | 4, directionId?: number, stopDisruptions?: boolean, includeGeopath?: boolean, geopathUtc?: Date, token?: string, devid?: string, signature?: string, options?: any) {
            return StopsApiFp(configuration).stopsStopsForRoute(routeId, routeType, directionId, stopDisruptions, includeGeopath, geopathUtc, token, devid, signature, options)(fetch, basePath);
        },
    };
};

/**
 * StopsApi - object-oriented interface
 * @export
 * @class StopsApi
 * @extends {BaseAPI}
 */
export class StopsApi extends BaseAPI {
    /**
     * 
     * @summary View facilities at a specific stop (Metro and V/Line stations only)
     * @param {number} stopId Identifier of stop; values returned by Stops API
     * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
     * @param {boolean} [stopLocation] Indicates if stop location information will be returned (default &#x3D; false)
     * @param {boolean} [stopAmenities] Indicates if stop amenity information will be returned (default &#x3D; false)
     * @param {boolean} [stopAccessibility] Indicates if stop accessibility information will be returned (default &#x3D; false)
     * @param {boolean} [stopContact] Indicates if stop contact information will be returned (default &#x3D; false)
     * @param {boolean} [stopTicket] Indicates if stop ticket information will be returned (default &#x3D; false)
     * @param {boolean} [gtfs] Incdicates whether the stop_id is a GTFS ID or not
     * @param {boolean} [stopStaffing] Indicates if stop staffing information will be returned (default &#x3D; false)
     * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StopsApi
     */
    public stopsStopDetails(stopId: number, routeType: 0 | 1 | 2 | 3 | 4, stopLocation?: boolean, stopAmenities?: boolean, stopAccessibility?: boolean, stopContact?: boolean, stopTicket?: boolean, gtfs?: boolean, stopStaffing?: boolean, stopDisruptions?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
        return StopsApiFp(this.configuration).stopsStopDetails(stopId, routeType, stopLocation, stopAmenities, stopAccessibility, stopContact, stopTicket, gtfs, stopStaffing, stopDisruptions, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View all stops near a specific location
     * @param {number} latitude Geographic coordinate of latitude
     * @param {number} longitude Geographic coordinate of longitude
     * @param {Array<0 | 1 | 2 | 3 | 4>} [routeTypes] Filter by route_type; values returned via RouteTypes API
     * @param {number} [maxResults] Maximum number of results returned (default &#x3D; 30)
     * @param {number} [maxDistance] Filter by maximum distance (in metres) from location specified via latitude and longitude parameters (default &#x3D; 300)
     * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StopsApi
     */
    public stopsStopsByGeolocation(latitude: number, longitude: number, routeTypes?: Array<0 | 1 | 2 | 3 | 4>, maxResults?: number, maxDistance?: number, stopDisruptions?: boolean, token?: string, devid?: string, signature?: string, options?: any) {
        return StopsApiFp(this.configuration).stopsStopsByGeolocation(latitude, longitude, routeTypes, maxResults, maxDistance, stopDisruptions, token, devid, signature, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View all stops on a specific route
     * @param {number} routeId Identifier of route; values returned by Routes API - v3/routes
     * @param {0 | 1 | 2 | 3 | 4} routeType Number identifying transport mode; values returned via RouteTypes API
     * @param {number} [directionId] An optional direction; values returned by Directions API. When this is set, stop sequence information is returned in the response.
     * @param {boolean} [stopDisruptions] Indicates if stop disruption information will be returned (default &#x3D; false)
     * @param {boolean} [includeGeopath] Indicates if geopath data will be returned (default &#x3D; false)
     * @param {Date} [geopathUtc] Filter geopaths by date (ISO 8601 UTC format) (default &#x3D; current date)
     * @param {string} [token] Please ignore
     * @param {string} [devid] Your developer id
     * @param {string} [signature] Authentication signature for request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StopsApi
     */
    public stopsStopsForRoute(routeId: number, routeType: 0 | 1 | 2 | 3 | 4, directionId?: number, stopDisruptions?: boolean, includeGeopath?: boolean, geopathUtc?: Date, token?: string, devid?: string, signature?: string, options?: any) {
        return StopsApiFp(this.configuration).stopsStopsForRoute(routeId, routeType, directionId, stopDisruptions, includeGeopath, geopathUtc, token, devid, signature, options)(this.fetch, this.basePath);
    }

}

