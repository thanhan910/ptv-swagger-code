// Models.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for case let (key, value) as (String, String) in rawHeader {
            header[key] = value
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        switch Decoders.decode(clazz: T.self, source: source, instance: nil) {
    	    case let .success(value):
                return .success(value)
            case let .failure(error):
                return .failure(error)
        }
    }

    static open func decode<T: RawRepresentable>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }
        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> where T: RawRepresentable {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decodeOptional(clazz: T.self, source: sourceValue) {
                case let .success(value): if let value = value { values.append(value) }
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject>(clazz: T, source: AnyObject) -> Decoded<T?> where T.RawValue == U {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for [V3BulkDeparturesRequest]
        Decoders.addDecoder(clazz: [V3BulkDeparturesRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3BulkDeparturesRequest]> in
            return Decoders.decode(clazz: [V3BulkDeparturesRequest].self, source: source)
        }

        // Decoder for V3BulkDeparturesRequest
        Decoders.addDecoder(clazz: V3BulkDeparturesRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3BulkDeparturesRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3BulkDeparturesRequest() : instance as! V3BulkDeparturesRequest
                switch Decoders.decodeOptional(clazz: [V3StopDepartureRequest].self, source: sourceDictionary["requests"] as AnyObject?) {
                case let .success(value): _result.requests = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["date_utc"] as AnyObject?) {
                case let .success(value): _result.dateUtc = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["look_backwards"] as AnyObject?) {
                case let .success(value): _result.lookBackwards = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["include_cancelled"] as AnyObject?) {
                case let .success(value): _result.includeCancelled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["include_geopath"] as AnyObject?) {
                case let .success(value): _result.includeGeopath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Array<V3BulkDeparturesRequest.Expand>.self, source: sourceDictionary["expand"] as AnyObject?) {
                case let .success(value): _result.expand = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3BulkDeparturesRequest", actual: "\(source)"))
            }
        }
        // Decoder for [V3BulkDeparturesResponse]
        Decoders.addDecoder(clazz: [V3BulkDeparturesResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3BulkDeparturesResponse]> in
            return Decoders.decode(clazz: [V3BulkDeparturesResponse].self, source: source)
        }

        // Decoder for V3BulkDeparturesResponse
        Decoders.addDecoder(clazz: V3BulkDeparturesResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3BulkDeparturesResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3BulkDeparturesResponse() : instance as! V3BulkDeparturesResponse
                switch Decoders.decodeOptional(clazz: [V3BulkDeparturesUpdateResponse].self, source: sourceDictionary["responses"] as AnyObject?) {
                case let .success(value): _result.responses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3BulkDeparturesStopResponse].self, source: sourceDictionary["stops"] as AnyObject?) {
                case let .success(value): _result.stops = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["routes"] as AnyObject?) {
                case let .success(value): _result.routes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Run].self, source: sourceDictionary["runs"] as AnyObject?) {
                case let .success(value): _result.runs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Direction].self, source: sourceDictionary["directions"] as AnyObject?) {
                case let .success(value): _result.directions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3Disruption].self, source: sourceDictionary["disruptions"] as AnyObject?) {
                case let .success(value): _result.disruptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3BulkDeparturesResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3BulkDeparturesRouteDirectionResponse]
        Decoders.addDecoder(clazz: [V3BulkDeparturesRouteDirectionResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3BulkDeparturesRouteDirectionResponse]> in
            return Decoders.decode(clazz: [V3BulkDeparturesRouteDirectionResponse].self, source: source)
        }

        // Decoder for V3BulkDeparturesRouteDirectionResponse
        Decoders.addDecoder(clazz: V3BulkDeparturesRouteDirectionResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3BulkDeparturesRouteDirectionResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3BulkDeparturesRouteDirectionResponse() : instance as! V3BulkDeparturesRouteDirectionResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["direction_name"] as AnyObject?) {
                case let .success(value): _result.directionName = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3BulkDeparturesRouteDirectionResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3BulkDeparturesStopResponse]
        Decoders.addDecoder(clazz: [V3BulkDeparturesStopResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3BulkDeparturesStopResponse]> in
            return Decoders.decode(clazz: [V3BulkDeparturesStopResponse].self, source: source)
        }

        // Decoder for V3BulkDeparturesStopResponse
        Decoders.addDecoder(clazz: V3BulkDeparturesStopResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3BulkDeparturesStopResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3BulkDeparturesStopResponse() : instance as! V3BulkDeparturesStopResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_name"] as AnyObject?) {
                case let .success(value): _result.stopName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_latitude"] as AnyObject?) {
                case let .success(value): _result.stopLatitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_longitude"] as AnyObject?) {
                case let .success(value): _result.stopLongitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_suburb"] as AnyObject?) {
                case let .success(value): _result.stopSuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_landmark"] as AnyObject?) {
                case let .success(value): _result.stopLandmark = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3BulkDeparturesStopResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3BulkDeparturesUpdateResponse]
        Decoders.addDecoder(clazz: [V3BulkDeparturesUpdateResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3BulkDeparturesUpdateResponse]> in
            return Decoders.decode(clazz: [V3BulkDeparturesUpdateResponse].self, source: source)
        }

        // Decoder for V3BulkDeparturesUpdateResponse
        Decoders.addDecoder(clazz: V3BulkDeparturesUpdateResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3BulkDeparturesUpdateResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3BulkDeparturesUpdateResponse() : instance as! V3BulkDeparturesUpdateResponse
                switch Decoders.decodeOptional(clazz: [V3Departure].self, source: sourceDictionary["departures"] as AnyObject?) {
                case let .success(value): _result.departures = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3BulkDeparturesRouteDirectionResponse.self, source: sourceDictionary["requested_route_direction"] as AnyObject?) {
                case let .success(value): _result.requestedRouteDirection = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3BulkDeparturesUpdateResponse.RouteDirectionStatus.self, source: sourceDictionary["route_direction_status"] as AnyObject?) {
                case let .success(value): _result.routeDirectionStatus = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3BulkDeparturesRouteDirectionResponse.self, source: sourceDictionary["route_direction"] as AnyObject?) {
                case let .success(value): _result.routeDirection = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3BulkDeparturesUpdateResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3Departure]
        Decoders.addDecoder(clazz: [V3Departure].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3Departure]> in
            return Decoders.decode(clazz: [V3Departure].self, source: source)
        }

        // Decoder for V3Departure
        Decoders.addDecoder(clazz: V3Departure.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3Departure> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3Departure() : instance as! V3Departure
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["run_id"] as AnyObject?) {
                case let .success(value): _result.runId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["run_ref"] as AnyObject?) {
                case let .success(value): _result.runRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["disruption_ids"] as AnyObject?) {
                case let .success(value): _result.disruptionIds = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["scheduled_departure_utc"] as AnyObject?) {
                case let .success(value): _result.scheduledDepartureUtc = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["estimated_departure_utc"] as AnyObject?) {
                case let .success(value): _result.estimatedDepartureUtc = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["at_platform"] as AnyObject?) {
                case let .success(value): _result.atPlatform = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["platform_number"] as AnyObject?) {
                case let .success(value): _result.platformNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["flags"] as AnyObject?) {
                case let .success(value): _result.flags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["departure_sequence"] as AnyObject?) {
                case let .success(value): _result.departureSequence = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3Departure", actual: "\(source)"))
            }
        }
        // Decoder for [V3DeparturesBroadParameters]
        Decoders.addDecoder(clazz: [V3DeparturesBroadParameters].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DeparturesBroadParameters]> in
            return Decoders.decode(clazz: [V3DeparturesBroadParameters].self, source: source)
        }

        // Decoder for V3DeparturesBroadParameters
        Decoders.addDecoder(clazz: V3DeparturesBroadParameters.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DeparturesBroadParameters> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DeparturesBroadParameters() : instance as! V3DeparturesBroadParameters
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["platform_numbers"] as AnyObject?) {
                case let .success(value): _result.platformNumbers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["gtfs"] as AnyObject?) {
                case let .success(value): _result.gtfs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["date_utc"] as AnyObject?) {
                case let .success(value): _result.dateUtc = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_results"] as AnyObject?) {
                case let .success(value): _result.maxResults = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["include_cancelled"] as AnyObject?) {
                case let .success(value): _result.includeCancelled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["look_backwards"] as AnyObject?) {
                case let .success(value): _result.lookBackwards = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Array<V3DeparturesBroadParameters.Expand>.self, source: sourceDictionary["expand"] as AnyObject?) {
                case let .success(value): _result.expand = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["include_geopath"] as AnyObject?) {
                case let .success(value): _result.includeGeopath = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DeparturesBroadParameters", actual: "\(source)"))
            }
        }
        // Decoder for [V3DeparturesResponse]
        Decoders.addDecoder(clazz: [V3DeparturesResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DeparturesResponse]> in
            return Decoders.decode(clazz: [V3DeparturesResponse].self, source: source)
        }

        // Decoder for V3DeparturesResponse
        Decoders.addDecoder(clazz: V3DeparturesResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DeparturesResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DeparturesResponse() : instance as! V3DeparturesResponse
                switch Decoders.decodeOptional(clazz: [V3Departure].self, source: sourceDictionary["departures"] as AnyObject?) {
                case let .success(value): _result.departures = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3StopModel].self, source: sourceDictionary["stops"] as AnyObject?) {
                case let .success(value): _result.stops = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:Any].self, source: sourceDictionary["routes"] as AnyObject?) {
                case let .success(value): _result.routes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3Run].self, source: sourceDictionary["runs"] as AnyObject?) {
                case let .success(value): _result.runs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3Direction].self, source: sourceDictionary["directions"] as AnyObject?) {
                case let .success(value): _result.directions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3Disruption].self, source: sourceDictionary["disruptions"] as AnyObject?) {
                case let .success(value): _result.disruptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DeparturesResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3DeparturesSpecificParameters]
        Decoders.addDecoder(clazz: [V3DeparturesSpecificParameters].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DeparturesSpecificParameters]> in
            return Decoders.decode(clazz: [V3DeparturesSpecificParameters].self, source: source)
        }

        // Decoder for V3DeparturesSpecificParameters
        Decoders.addDecoder(clazz: V3DeparturesSpecificParameters.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DeparturesSpecificParameters> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DeparturesSpecificParameters() : instance as! V3DeparturesSpecificParameters
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["gtfs"] as AnyObject?) {
                case let .success(value): _result.gtfs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["date_utc"] as AnyObject?) {
                case let .success(value): _result.dateUtc = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_results"] as AnyObject?) {
                case let .success(value): _result.maxResults = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["include_cancelled"] as AnyObject?) {
                case let .success(value): _result.includeCancelled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["look_backwards"] as AnyObject?) {
                case let .success(value): _result.lookBackwards = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Array<V3DeparturesSpecificParameters.Expand>.self, source: sourceDictionary["expand"] as AnyObject?) {
                case let .success(value): _result.expand = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["include_geopath"] as AnyObject?) {
                case let .success(value): _result.includeGeopath = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DeparturesSpecificParameters", actual: "\(source)"))
            }
        }
        // Decoder for [V3Direction]
        Decoders.addDecoder(clazz: [V3Direction].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3Direction]> in
            return Decoders.decode(clazz: [V3Direction].self, source: source)
        }

        // Decoder for V3Direction
        Decoders.addDecoder(clazz: V3Direction.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3Direction> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3Direction() : instance as! V3Direction
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["direction_name"] as AnyObject?) {
                case let .success(value): _result.directionName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3Direction", actual: "\(source)"))
            }
        }
        // Decoder for [V3DirectionWithDescription]
        Decoders.addDecoder(clazz: [V3DirectionWithDescription].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DirectionWithDescription]> in
            return Decoders.decode(clazz: [V3DirectionWithDescription].self, source: source)
        }

        // Decoder for V3DirectionWithDescription
        Decoders.addDecoder(clazz: V3DirectionWithDescription.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DirectionWithDescription> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DirectionWithDescription() : instance as! V3DirectionWithDescription
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_direction_description"] as AnyObject?) {
                case let .success(value): _result.routeDirectionDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["direction_name"] as AnyObject?) {
                case let .success(value): _result.directionName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DirectionWithDescription", actual: "\(source)"))
            }
        }
        // Decoder for [V3DirectionsResponse]
        Decoders.addDecoder(clazz: [V3DirectionsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DirectionsResponse]> in
            return Decoders.decode(clazz: [V3DirectionsResponse].self, source: source)
        }

        // Decoder for V3DirectionsResponse
        Decoders.addDecoder(clazz: V3DirectionsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DirectionsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DirectionsResponse() : instance as! V3DirectionsResponse
                switch Decoders.decodeOptional(clazz: [V3DirectionWithDescription].self, source: sourceDictionary["directions"] as AnyObject?) {
                case let .success(value): _result.directions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DirectionsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3Disruption]
        Decoders.addDecoder(clazz: [V3Disruption].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3Disruption]> in
            return Decoders.decode(clazz: [V3Disruption].self, source: source)
        }

        // Decoder for V3Disruption
        Decoders.addDecoder(clazz: V3Disruption.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3Disruption> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3Disruption() : instance as! V3Disruption
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["disruption_id"] as AnyObject?) {
                case let .success(value): _result.disruptionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                case let .success(value): _result.title = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                case let .success(value): _result.url = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["disruption_status"] as AnyObject?) {
                case let .success(value): _result.disruptionStatus = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["disruption_type"] as AnyObject?) {
                case let .success(value): _result.disruptionType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["published_on"] as AnyObject?) {
                case let .success(value): _result.publishedOn = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["last_updated"] as AnyObject?) {
                case let .success(value): _result.lastUpdated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["from_date"] as AnyObject?) {
                case let .success(value): _result.fromDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["to_date"] as AnyObject?) {
                case let .success(value): _result.toDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3DisruptionRoute].self, source: sourceDictionary["routes"] as AnyObject?) {
                case let .success(value): _result.routes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3DisruptionStop].self, source: sourceDictionary["stops"] as AnyObject?) {
                case let .success(value): _result.stops = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["colour"] as AnyObject?) {
                case let .success(value): _result.colour = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["display_on_board"] as AnyObject?) {
                case let .success(value): _result.displayOnBoard = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["display_status"] as AnyObject?) {
                case let .success(value): _result.displayStatus = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3Disruption", actual: "\(source)"))
            }
        }
        // Decoder for [V3DisruptionDirection]
        Decoders.addDecoder(clazz: [V3DisruptionDirection].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DisruptionDirection]> in
            return Decoders.decode(clazz: [V3DisruptionDirection].self, source: source)
        }

        // Decoder for V3DisruptionDirection
        Decoders.addDecoder(clazz: V3DisruptionDirection.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DisruptionDirection> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DisruptionDirection() : instance as! V3DisruptionDirection
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_direction_id"] as AnyObject?) {
                case let .success(value): _result.routeDirectionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["direction_name"] as AnyObject?) {
                case let .success(value): _result.directionName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["service_time"] as AnyObject?) {
                case let .success(value): _result.serviceTime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DisruptionDirection", actual: "\(source)"))
            }
        }
        // Decoder for [V3DisruptionMode]
        Decoders.addDecoder(clazz: [V3DisruptionMode].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DisruptionMode]> in
            return Decoders.decode(clazz: [V3DisruptionMode].self, source: source)
        }

        // Decoder for V3DisruptionMode
        Decoders.addDecoder(clazz: V3DisruptionMode.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DisruptionMode> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DisruptionMode() : instance as! V3DisruptionMode
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["disruption_mode_name"] as AnyObject?) {
                case let .success(value): _result.disruptionModeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["disruption_mode"] as AnyObject?) {
                case let .success(value): _result.disruptionMode = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DisruptionMode", actual: "\(source)"))
            }
        }
        // Decoder for [V3DisruptionModesResponse]
        Decoders.addDecoder(clazz: [V3DisruptionModesResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DisruptionModesResponse]> in
            return Decoders.decode(clazz: [V3DisruptionModesResponse].self, source: source)
        }

        // Decoder for V3DisruptionModesResponse
        Decoders.addDecoder(clazz: V3DisruptionModesResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DisruptionModesResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DisruptionModesResponse() : instance as! V3DisruptionModesResponse
                switch Decoders.decodeOptional(clazz: [V3DisruptionMode].self, source: sourceDictionary["disruption_modes"] as AnyObject?) {
                case let .success(value): _result.disruptionModes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DisruptionModesResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3DisruptionResponse]
        Decoders.addDecoder(clazz: [V3DisruptionResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DisruptionResponse]> in
            return Decoders.decode(clazz: [V3DisruptionResponse].self, source: source)
        }

        // Decoder for V3DisruptionResponse
        Decoders.addDecoder(clazz: V3DisruptionResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DisruptionResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DisruptionResponse() : instance as! V3DisruptionResponse
                switch Decoders.decodeOptional(clazz: V3Disruption.self, source: sourceDictionary["disruption"] as AnyObject?) {
                case let .success(value): _result.disruption = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DisruptionResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3DisruptionRoute]
        Decoders.addDecoder(clazz: [V3DisruptionRoute].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DisruptionRoute]> in
            return Decoders.decode(clazz: [V3DisruptionRoute].self, source: source)
        }

        // Decoder for V3DisruptionRoute
        Decoders.addDecoder(clazz: V3DisruptionRoute.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DisruptionRoute> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DisruptionRoute() : instance as! V3DisruptionRoute
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_name"] as AnyObject?) {
                case let .success(value): _result.routeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_number"] as AnyObject?) {
                case let .success(value): _result.routeNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_gtfs_id"] as AnyObject?) {
                case let .success(value): _result.routeGtfsId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3DisruptionDirection.self, source: sourceDictionary["direction"] as AnyObject?) {
                case let .success(value): _result.direction = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DisruptionRoute", actual: "\(source)"))
            }
        }
        // Decoder for [V3DisruptionStop]
        Decoders.addDecoder(clazz: [V3DisruptionStop].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DisruptionStop]> in
            return Decoders.decode(clazz: [V3DisruptionStop].self, source: source)
        }

        // Decoder for V3DisruptionStop
        Decoders.addDecoder(clazz: V3DisruptionStop.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DisruptionStop> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DisruptionStop() : instance as! V3DisruptionStop
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_name"] as AnyObject?) {
                case let .success(value): _result.stopName = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DisruptionStop", actual: "\(source)"))
            }
        }
        // Decoder for [V3Disruptions]
        Decoders.addDecoder(clazz: [V3Disruptions].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3Disruptions]> in
            return Decoders.decode(clazz: [V3Disruptions].self, source: source)
        }

        // Decoder for V3Disruptions
        Decoders.addDecoder(clazz: V3Disruptions.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3Disruptions> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3Disruptions() : instance as! V3Disruptions
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["general"] as AnyObject?) {
                case let .success(value): _result.general = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["metro_train"] as AnyObject?) {
                case let .success(value): _result.metroTrain = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["metro_tram"] as AnyObject?) {
                case let .success(value): _result.metroTram = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["metro_bus"] as AnyObject?) {
                case let .success(value): _result.metroBus = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["regional_train"] as AnyObject?) {
                case let .success(value): _result.regionalTrain = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["regional_coach"] as AnyObject?) {
                case let .success(value): _result.regionalCoach = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["regional_bus"] as AnyObject?) {
                case let .success(value): _result.regionalBus = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["school_bus"] as AnyObject?) {
                case let .success(value): _result.schoolBus = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["telebus"] as AnyObject?) {
                case let .success(value): _result.telebus = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["night_bus"] as AnyObject?) {
                case let .success(value): _result.nightBus = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["ferry"] as AnyObject?) {
                case let .success(value): _result.ferry = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["interstate_train"] as AnyObject?) {
                case let .success(value): _result.interstateTrain = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["skybus"] as AnyObject?) {
                case let .success(value): _result.skybus = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["taxi"] as AnyObject?) {
                case let .success(value): _result.taxi = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3Disruptions", actual: "\(source)"))
            }
        }
        // Decoder for [V3DisruptionsResponse]
        Decoders.addDecoder(clazz: [V3DisruptionsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DisruptionsResponse]> in
            return Decoders.decode(clazz: [V3DisruptionsResponse].self, source: source)
        }

        // Decoder for V3DisruptionsResponse
        Decoders.addDecoder(clazz: V3DisruptionsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DisruptionsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DisruptionsResponse() : instance as! V3DisruptionsResponse
                switch Decoders.decodeOptional(clazz: V3Disruptions.self, source: sourceDictionary["disruptions"] as AnyObject?) {
                case let .success(value): _result.disruptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DisruptionsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3DynamoDbTimetable]
        Decoders.addDecoder(clazz: [V3DynamoDbTimetable].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DynamoDbTimetable]> in
            return Decoders.decode(clazz: [V3DynamoDbTimetable].self, source: source)
        }

        // Decoder for V3DynamoDbTimetable
        Decoders.addDecoder(clazz: V3DynamoDbTimetable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DynamoDbTimetable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DynamoDbTimetable() : instance as! V3DynamoDbTimetable
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["table_name"] as AnyObject?) {
                case let .success(value): _result.tableName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["parser_version"] as AnyObject?) {
                case let .success(value): _result.parserVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parser_mapping_version"] as AnyObject?) {
                case let .success(value): _result.parserMappingVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["pt_version"] as AnyObject?) {
                case let .success(value): _result.ptVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pt_mapping_version"] as AnyObject?) {
                case let .success(value): _result.ptMappingVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3DynamoDbTimetable.TransportType.self, source: sourceDictionary["transport_type"] as AnyObject?) {
                case let .success(value): _result.transportType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["applicable_local_date"] as AnyObject?) {
                case let .success(value): _result.applicableLocalDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["exists"] as AnyObject?) {
                case let .success(value): _result.exists = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DynamoDbTimetable", actual: "\(source)"))
            }
        }
        // Decoder for [V3DynamoDbTimetablesReponse]
        Decoders.addDecoder(clazz: [V3DynamoDbTimetablesReponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3DynamoDbTimetablesReponse]> in
            return Decoders.decode(clazz: [V3DynamoDbTimetablesReponse].self, source: source)
        }

        // Decoder for V3DynamoDbTimetablesReponse
        Decoders.addDecoder(clazz: V3DynamoDbTimetablesReponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3DynamoDbTimetablesReponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3DynamoDbTimetablesReponse() : instance as! V3DynamoDbTimetablesReponse
                switch Decoders.decodeOptional(clazz: [V3DynamoDbTimetable].self, source: sourceDictionary["timetables"] as AnyObject?) {
                case let .success(value): _result.timetables = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3DynamoDbTimetablesReponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3ErrorResponse]
        Decoders.addDecoder(clazz: [V3ErrorResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3ErrorResponse]> in
            return Decoders.decode(clazz: [V3ErrorResponse].self, source: source)
        }

        // Decoder for V3ErrorResponse
        Decoders.addDecoder(clazz: V3ErrorResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3ErrorResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3ErrorResponse() : instance as! V3ErrorResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                case let .success(value): _result.message = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3ErrorResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3FareEstimateResponse]
        Decoders.addDecoder(clazz: [V3FareEstimateResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3FareEstimateResponse]> in
            return Decoders.decode(clazz: [V3FareEstimateResponse].self, source: source)
        }

        // Decoder for V3FareEstimateResponse
        Decoders.addDecoder(clazz: V3FareEstimateResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3FareEstimateResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3FareEstimateResponse() : instance as! V3FareEstimateResponse
                switch Decoders.decodeOptional(clazz: V3FareEstimateResultStatus.self, source: sourceDictionary["FareEstimateResultStatus"] as AnyObject?) {
                case let .success(value): _result.fareEstimateResultStatus = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3FareEstimateResult.self, source: sourceDictionary["FareEstimateResult"] as AnyObject?) {
                case let .success(value): _result.fareEstimateResult = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3FareEstimateResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3FareEstimateResult]
        Decoders.addDecoder(clazz: [V3FareEstimateResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3FareEstimateResult]> in
            return Decoders.decode(clazz: [V3FareEstimateResult].self, source: source)
        }

        // Decoder for V3FareEstimateResult
        Decoders.addDecoder(clazz: V3FareEstimateResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3FareEstimateResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3FareEstimateResult() : instance as! V3FareEstimateResult
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["IsEarlyBird"] as AnyObject?) {
                case let .success(value): _result.isEarlyBird = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["IsJourneyInFreeTramZone"] as AnyObject?) {
                case let .success(value): _result.isJourneyInFreeTramZone = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["IsThisWeekendJourney"] as AnyObject?) {
                case let .success(value): _result.isThisWeekendJourney = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3ZoneInfo.self, source: sourceDictionary["ZoneInfo"] as AnyObject?) {
                case let .success(value): _result.zoneInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3PassengerFare].self, source: sourceDictionary["PassengerFares"] as AnyObject?) {
                case let .success(value): _result.passengerFares = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3FareEstimateResult", actual: "\(source)"))
            }
        }
        // Decoder for [V3FareEstimateResultStatus]
        Decoders.addDecoder(clazz: [V3FareEstimateResultStatus].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3FareEstimateResultStatus]> in
            return Decoders.decode(clazz: [V3FareEstimateResultStatus].self, source: source)
        }

        // Decoder for V3FareEstimateResultStatus
        Decoders.addDecoder(clazz: V3FareEstimateResultStatus.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3FareEstimateResultStatus> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3FareEstimateResultStatus() : instance as! V3FareEstimateResultStatus
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["StatusCode"] as AnyObject?) {
                case let .success(value): _result.statusCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Message"] as AnyObject?) {
                case let .success(value): _result.message = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3FareEstimateResultStatus", actual: "\(source)"))
            }
        }
        // Decoder for [V3GenerateDivaMappingResponse]
        Decoders.addDecoder(clazz: [V3GenerateDivaMappingResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3GenerateDivaMappingResponse]> in
            return Decoders.decode(clazz: [V3GenerateDivaMappingResponse].self, source: source)
        }

        // Decoder for V3GenerateDivaMappingResponse
        Decoders.addDecoder(clazz: V3GenerateDivaMappingResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3GenerateDivaMappingResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3GenerateDivaMappingResponse() : instance as! V3GenerateDivaMappingResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mapping_version"] as AnyObject?) {
                case let .success(value): _result.mappingVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3GenerateDivaMappingResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3Outlet]
        Decoders.addDecoder(clazz: [V3Outlet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3Outlet]> in
            return Decoders.decode(clazz: [V3Outlet].self, source: source)
        }

        // Decoder for V3Outlet
        Decoders.addDecoder(clazz: V3Outlet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3Outlet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3Outlet() : instance as! V3Outlet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_slid_spid"] as AnyObject?) {
                case let .success(value): _result.outletSlidSpid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_name"] as AnyObject?) {
                case let .success(value): _result.outletName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business"] as AnyObject?) {
                case let .success(value): _result.outletBusiness = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["outlet_latitude"] as AnyObject?) {
                case let .success(value): _result.outletLatitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["outlet_longitude"] as AnyObject?) {
                case let .success(value): _result.outletLongitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_suburb"] as AnyObject?) {
                case let .success(value): _result.outletSuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["outlet_postcode"] as AnyObject?) {
                case let .success(value): _result.outletPostcode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_mon"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourMon = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_tue"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourTue = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_wed"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourWed = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_thur"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourThur = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_fri"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourFri = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_sat"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourSat = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_sun"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourSun = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_notes"] as AnyObject?) {
                case let .success(value): _result.outletNotes = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3Outlet", actual: "\(source)"))
            }
        }
        // Decoder for [V3OutletGeolocation]
        Decoders.addDecoder(clazz: [V3OutletGeolocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3OutletGeolocation]> in
            return Decoders.decode(clazz: [V3OutletGeolocation].self, source: source)
        }

        // Decoder for V3OutletGeolocation
        Decoders.addDecoder(clazz: V3OutletGeolocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3OutletGeolocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3OutletGeolocation() : instance as! V3OutletGeolocation
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["outlet_distance"] as AnyObject?) {
                case let .success(value): _result.outletDistance = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_slid_spid"] as AnyObject?) {
                case let .success(value): _result.outletSlidSpid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_name"] as AnyObject?) {
                case let .success(value): _result.outletName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business"] as AnyObject?) {
                case let .success(value): _result.outletBusiness = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["outlet_latitude"] as AnyObject?) {
                case let .success(value): _result.outletLatitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["outlet_longitude"] as AnyObject?) {
                case let .success(value): _result.outletLongitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_suburb"] as AnyObject?) {
                case let .success(value): _result.outletSuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["outlet_postcode"] as AnyObject?) {
                case let .success(value): _result.outletPostcode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_mon"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourMon = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_tue"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourTue = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_wed"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourWed = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_thur"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourThur = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_fri"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourFri = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_sat"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourSat = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_sun"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourSun = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_notes"] as AnyObject?) {
                case let .success(value): _result.outletNotes = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3OutletGeolocation", actual: "\(source)"))
            }
        }
        // Decoder for [V3OutletGeolocationParameters]
        Decoders.addDecoder(clazz: [V3OutletGeolocationParameters].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3OutletGeolocationParameters]> in
            return Decoders.decode(clazz: [V3OutletGeolocationParameters].self, source: source)
        }

        // Decoder for V3OutletGeolocationParameters
        Decoders.addDecoder(clazz: V3OutletGeolocationParameters.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3OutletGeolocationParameters> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3OutletGeolocationParameters() : instance as! V3OutletGeolocationParameters
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["max_distance"] as AnyObject?) {
                case let .success(value): _result.maxDistance = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_results"] as AnyObject?) {
                case let .success(value): _result.maxResults = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3OutletGeolocationParameters", actual: "\(source)"))
            }
        }
        // Decoder for [V3OutletGeolocationResponse]
        Decoders.addDecoder(clazz: [V3OutletGeolocationResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3OutletGeolocationResponse]> in
            return Decoders.decode(clazz: [V3OutletGeolocationResponse].self, source: source)
        }

        // Decoder for V3OutletGeolocationResponse
        Decoders.addDecoder(clazz: V3OutletGeolocationResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3OutletGeolocationResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3OutletGeolocationResponse() : instance as! V3OutletGeolocationResponse
                switch Decoders.decodeOptional(clazz: [V3OutletGeolocation].self, source: sourceDictionary["outlets"] as AnyObject?) {
                case let .success(value): _result.outlets = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3OutletGeolocationResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3OutletParameters]
        Decoders.addDecoder(clazz: [V3OutletParameters].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3OutletParameters]> in
            return Decoders.decode(clazz: [V3OutletParameters].self, source: source)
        }

        // Decoder for V3OutletParameters
        Decoders.addDecoder(clazz: V3OutletParameters.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3OutletParameters> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3OutletParameters() : instance as! V3OutletParameters
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_results"] as AnyObject?) {
                case let .success(value): _result.maxResults = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3OutletParameters", actual: "\(source)"))
            }
        }
        // Decoder for [V3OutletResponse]
        Decoders.addDecoder(clazz: [V3OutletResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3OutletResponse]> in
            return Decoders.decode(clazz: [V3OutletResponse].self, source: source)
        }

        // Decoder for V3OutletResponse
        Decoders.addDecoder(clazz: V3OutletResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3OutletResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3OutletResponse() : instance as! V3OutletResponse
                switch Decoders.decodeOptional(clazz: [V3Outlet].self, source: sourceDictionary["outlets"] as AnyObject?) {
                case let .success(value): _result.outlets = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3OutletResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3PassengerFare]
        Decoders.addDecoder(clazz: [V3PassengerFare].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3PassengerFare]> in
            return Decoders.decode(clazz: [V3PassengerFare].self, source: source)
        }

        // Decoder for V3PassengerFare
        Decoders.addDecoder(clazz: V3PassengerFare.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3PassengerFare> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3PassengerFare() : instance as! V3PassengerFare
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["PassengerType"] as AnyObject?) {
                case let .success(value): _result.passengerType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: BigDecimal.self, source: sourceDictionary["Fare2HourPeak"] as AnyObject?) {
                case let .success(value): _result.fare2HourPeak = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: BigDecimal.self, source: sourceDictionary["Fare2HourOffPeak"] as AnyObject?) {
                case let .success(value): _result.fare2HourOffPeak = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: BigDecimal.self, source: sourceDictionary["FareDailyPeak"] as AnyObject?) {
                case let .success(value): _result.fareDailyPeak = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: BigDecimal.self, source: sourceDictionary["FareDailyOffPeak"] as AnyObject?) {
                case let .success(value): _result.fareDailyOffPeak = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: BigDecimal.self, source: sourceDictionary["Pass7Days"] as AnyObject?) {
                case let .success(value): _result.pass7Days = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: BigDecimal.self, source: sourceDictionary["Pass28To69DayPerDay"] as AnyObject?) {
                case let .success(value): _result.pass28To69DayPerDay = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: BigDecimal.self, source: sourceDictionary["Pass70PlusDayPerDay"] as AnyObject?) {
                case let .success(value): _result.pass70PlusDayPerDay = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: BigDecimal.self, source: sourceDictionary["WeekendCap"] as AnyObject?) {
                case let .success(value): _result.weekendCap = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: BigDecimal.self, source: sourceDictionary["HolidayCap"] as AnyObject?) {
                case let .success(value): _result.holidayCap = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3PassengerFare", actual: "\(source)"))
            }
        }
        // Decoder for [V3PatternDeparture]
        Decoders.addDecoder(clazz: [V3PatternDeparture].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3PatternDeparture]> in
            return Decoders.decode(clazz: [V3PatternDeparture].self, source: source)
        }

        // Decoder for V3PatternDeparture
        Decoders.addDecoder(clazz: V3PatternDeparture.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3PatternDeparture> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3PatternDeparture() : instance as! V3PatternDeparture
                switch Decoders.decodeOptional(clazz: [V3StopModel].self, source: sourceDictionary["skipped_stops"] as AnyObject?) {
                case let .success(value): _result.skippedStops = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["run_id"] as AnyObject?) {
                case let .success(value): _result.runId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["run_ref"] as AnyObject?) {
                case let .success(value): _result.runRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["disruption_ids"] as AnyObject?) {
                case let .success(value): _result.disruptionIds = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["scheduled_departure_utc"] as AnyObject?) {
                case let .success(value): _result.scheduledDepartureUtc = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["estimated_departure_utc"] as AnyObject?) {
                case let .success(value): _result.estimatedDepartureUtc = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["at_platform"] as AnyObject?) {
                case let .success(value): _result.atPlatform = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["platform_number"] as AnyObject?) {
                case let .success(value): _result.platformNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["flags"] as AnyObject?) {
                case let .success(value): _result.flags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["departure_sequence"] as AnyObject?) {
                case let .success(value): _result.departureSequence = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3PatternDeparture", actual: "\(source)"))
            }
        }
        // Decoder for [V3ResultOutlet]
        Decoders.addDecoder(clazz: [V3ResultOutlet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3ResultOutlet]> in
            return Decoders.decode(clazz: [V3ResultOutlet].self, source: source)
        }

        // Decoder for V3ResultOutlet
        Decoders.addDecoder(clazz: V3ResultOutlet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3ResultOutlet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3ResultOutlet() : instance as! V3ResultOutlet
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["outlet_distance"] as AnyObject?) {
                case let .success(value): _result.outletDistance = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_slid_spid"] as AnyObject?) {
                case let .success(value): _result.outletSlidSpid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_name"] as AnyObject?) {
                case let .success(value): _result.outletName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business"] as AnyObject?) {
                case let .success(value): _result.outletBusiness = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["outlet_latitude"] as AnyObject?) {
                case let .success(value): _result.outletLatitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["outlet_longitude"] as AnyObject?) {
                case let .success(value): _result.outletLongitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_suburb"] as AnyObject?) {
                case let .success(value): _result.outletSuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["outlet_postcode"] as AnyObject?) {
                case let .success(value): _result.outletPostcode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_mon"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourMon = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_tue"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourTue = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_wed"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourWed = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_thur"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourThur = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_fri"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourFri = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_sat"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourSat = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_business_hour_sun"] as AnyObject?) {
                case let .success(value): _result.outletBusinessHourSun = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outlet_notes"] as AnyObject?) {
                case let .success(value): _result.outletNotes = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3ResultOutlet", actual: "\(source)"))
            }
        }
        // Decoder for [V3ResultRoute]
        Decoders.addDecoder(clazz: [V3ResultRoute].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3ResultRoute]> in
            return Decoders.decode(clazz: [V3ResultRoute].self, source: source)
        }

        // Decoder for V3ResultRoute
        Decoders.addDecoder(clazz: V3ResultRoute.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3ResultRoute> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3ResultRoute() : instance as! V3ResultRoute
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_name"] as AnyObject?) {
                case let .success(value): _result.routeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_number"] as AnyObject?) {
                case let .success(value): _result.routeNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_gtfs_id"] as AnyObject?) {
                case let .success(value): _result.routeGtfsId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3RouteServiceStatus.self, source: sourceDictionary["route_service_status"] as AnyObject?) {
                case let .success(value): _result.routeServiceStatus = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3ResultRoute", actual: "\(source)"))
            }
        }
        // Decoder for [V3ResultStop]
        Decoders.addDecoder(clazz: [V3ResultStop].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3ResultStop]> in
            return Decoders.decode(clazz: [V3ResultStop].self, source: source)
        }

        // Decoder for V3ResultStop
        Decoders.addDecoder(clazz: V3ResultStop.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3ResultStop> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3ResultStop() : instance as! V3ResultStop
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_distance"] as AnyObject?) {
                case let .success(value): _result.stopDistance = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_suburb"] as AnyObject?) {
                case let .success(value): _result.stopSuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3ResultRoute].self, source: sourceDictionary["routes"] as AnyObject?) {
                case let .success(value): _result.routes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_latitude"] as AnyObject?) {
                case let .success(value): _result.stopLatitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_longitude"] as AnyObject?) {
                case let .success(value): _result.stopLongitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_sequence"] as AnyObject?) {
                case let .success(value): _result.stopSequence = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_name"] as AnyObject?) {
                case let .success(value): _result.stopName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_landmark"] as AnyObject?) {
                case let .success(value): _result.stopLandmark = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3ResultStop", actual: "\(source)"))
            }
        }
        // Decoder for [V3RouteDeparturesSpecificParameters]
        Decoders.addDecoder(clazz: [V3RouteDeparturesSpecificParameters].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3RouteDeparturesSpecificParameters]> in
            return Decoders.decode(clazz: [V3RouteDeparturesSpecificParameters].self, source: source)
        }

        // Decoder for V3RouteDeparturesSpecificParameters
        Decoders.addDecoder(clazz: V3RouteDeparturesSpecificParameters.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3RouteDeparturesSpecificParameters> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3RouteDeparturesSpecificParameters() : instance as! V3RouteDeparturesSpecificParameters
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["train_scheduled_timetables"] as AnyObject?) {
                case let .success(value): _result.trainScheduledTimetables = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["scheduled_timetables"] as AnyObject?) {
                case let .success(value): _result.scheduledTimetables = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["date_utc"] as AnyObject?) {
                case let .success(value): _result.dateUtc = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_results"] as AnyObject?) {
                case let .success(value): _result.maxResults = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["include_cancelled"] as AnyObject?) {
                case let .success(value): _result.includeCancelled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["look_backwards"] as AnyObject?) {
                case let .success(value): _result.lookBackwards = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Array<V3RouteDeparturesSpecificParameters.Expand>.self, source: sourceDictionary["expand"] as AnyObject?) {
                case let .success(value): _result.expand = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["include_geopath"] as AnyObject?) {
                case let .success(value): _result.includeGeopath = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3RouteDeparturesSpecificParameters", actual: "\(source)"))
            }
        }
        // Decoder for [V3RouteResponse]
        Decoders.addDecoder(clazz: [V3RouteResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3RouteResponse]> in
            return Decoders.decode(clazz: [V3RouteResponse].self, source: source)
        }

        // Decoder for V3RouteResponse
        Decoders.addDecoder(clazz: V3RouteResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3RouteResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3RouteResponse() : instance as! V3RouteResponse
                switch Decoders.decodeOptional(clazz: V3RouteWithStatus.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3RouteResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3RouteServiceStatus]
        Decoders.addDecoder(clazz: [V3RouteServiceStatus].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3RouteServiceStatus]> in
            return Decoders.decode(clazz: [V3RouteServiceStatus].self, source: source)
        }

        // Decoder for V3RouteServiceStatus
        Decoders.addDecoder(clazz: V3RouteServiceStatus.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3RouteServiceStatus> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3RouteServiceStatus() : instance as! V3RouteServiceStatus
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["timestamp"] as AnyObject?) {
                case let .success(value): _result.timestamp = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3RouteServiceStatus", actual: "\(source)"))
            }
        }
        // Decoder for [V3RouteType]
        Decoders.addDecoder(clazz: [V3RouteType].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3RouteType]> in
            return Decoders.decode(clazz: [V3RouteType].self, source: source)
        }

        // Decoder for V3RouteType
        Decoders.addDecoder(clazz: V3RouteType.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3RouteType> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3RouteType() : instance as! V3RouteType
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_type_name"] as AnyObject?) {
                case let .success(value): _result.routeTypeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3RouteType", actual: "\(source)"))
            }
        }
        // Decoder for [V3RouteTypesResponse]
        Decoders.addDecoder(clazz: [V3RouteTypesResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3RouteTypesResponse]> in
            return Decoders.decode(clazz: [V3RouteTypesResponse].self, source: source)
        }

        // Decoder for V3RouteTypesResponse
        Decoders.addDecoder(clazz: V3RouteTypesResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3RouteTypesResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3RouteTypesResponse() : instance as! V3RouteTypesResponse
                switch Decoders.decodeOptional(clazz: [V3RouteType].self, source: sourceDictionary["route_types"] as AnyObject?) {
                case let .success(value): _result.routeTypes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3RouteTypesResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3RouteWithStatus]
        Decoders.addDecoder(clazz: [V3RouteWithStatus].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3RouteWithStatus]> in
            return Decoders.decode(clazz: [V3RouteWithStatus].self, source: source)
        }

        // Decoder for V3RouteWithStatus
        Decoders.addDecoder(clazz: V3RouteWithStatus.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3RouteWithStatus> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3RouteWithStatus() : instance as! V3RouteWithStatus
                switch Decoders.decodeOptional(clazz: V3RouteServiceStatus.self, source: sourceDictionary["route_service_status"] as AnyObject?) {
                case let .success(value): _result.routeServiceStatus = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_name"] as AnyObject?) {
                case let .success(value): _result.routeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_number"] as AnyObject?) {
                case let .success(value): _result.routeNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_gtfs_id"] as AnyObject?) {
                case let .success(value): _result.routeGtfsId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["geopath"] as AnyObject?) {
                case let .success(value): _result.geopath = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3RouteWithStatus", actual: "\(source)"))
            }
        }
        // Decoder for [V3Run]
        Decoders.addDecoder(clazz: [V3Run].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3Run]> in
            return Decoders.decode(clazz: [V3Run].self, source: source)
        }

        // Decoder for V3Run
        Decoders.addDecoder(clazz: V3Run.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3Run> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3Run() : instance as! V3Run
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["run_id"] as AnyObject?) {
                case let .success(value): _result.runId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["run_ref"] as AnyObject?) {
                case let .success(value): _result.runRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["final_stop_id"] as AnyObject?) {
                case let .success(value): _result.finalStopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["destination_name"] as AnyObject?) {
                case let .success(value): _result.destinationName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["run_sequence"] as AnyObject?) {
                case let .success(value): _result.runSequence = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["express_stop_count"] as AnyObject?) {
                case let .success(value): _result.expressStopCount = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3VehiclePosition.self, source: sourceDictionary["vehicle_position"] as AnyObject?) {
                case let .success(value): _result.vehiclePosition = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3VehicleDescriptor.self, source: sourceDictionary["vehicle_descriptor"] as AnyObject?) {
                case let .success(value): _result.vehicleDescriptor = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["geopath"] as AnyObject?) {
                case let .success(value): _result.geopath = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3Run", actual: "\(source)"))
            }
        }
        // Decoder for [V3RunResponse]
        Decoders.addDecoder(clazz: [V3RunResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3RunResponse]> in
            return Decoders.decode(clazz: [V3RunResponse].self, source: source)
        }

        // Decoder for V3RunResponse
        Decoders.addDecoder(clazz: V3RunResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3RunResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3RunResponse() : instance as! V3RunResponse
                switch Decoders.decodeOptional(clazz: V3Run.self, source: sourceDictionary["run"] as AnyObject?) {
                case let .success(value): _result.run = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3RunResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3RunsResponse]
        Decoders.addDecoder(clazz: [V3RunsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3RunsResponse]> in
            return Decoders.decode(clazz: [V3RunsResponse].self, source: source)
        }

        // Decoder for V3RunsResponse
        Decoders.addDecoder(clazz: V3RunsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3RunsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3RunsResponse() : instance as! V3RunsResponse
                switch Decoders.decodeOptional(clazz: [V3Run].self, source: sourceDictionary["runs"] as AnyObject?) {
                case let .success(value): _result.runs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3RunsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3SearchParameters]
        Decoders.addDecoder(clazz: [V3SearchParameters].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SearchParameters]> in
            return Decoders.decode(clazz: [V3SearchParameters].self, source: source)
        }

        // Decoder for V3SearchParameters
        Decoders.addDecoder(clazz: V3SearchParameters.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SearchParameters> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SearchParameters() : instance as! V3SearchParameters
                switch Decoders.decodeOptional(clazz: Array<V3SearchParameters.RouteTypes>.self, source: sourceDictionary["route_types"] as AnyObject?) {
                case let .success(value): _result.routeTypes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["max_distance"] as AnyObject?) {
                case let .success(value): _result.maxDistance = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["include_addresses"] as AnyObject?) {
                case let .success(value): _result.includeAddresses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["include_outlets"] as AnyObject?) {
                case let .success(value): _result.includeOutlets = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["match_stop_by_suburb"] as AnyObject?) {
                case let .success(value): _result.matchStopBySuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["match_route_by_suburb"] as AnyObject?) {
                case let .success(value): _result.matchRouteBySuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["match_stop_by_gtfs_stop_id"] as AnyObject?) {
                case let .success(value): _result.matchStopByGtfsStopId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SearchParameters", actual: "\(source)"))
            }
        }
        // Decoder for [V3SearchResult]
        Decoders.addDecoder(clazz: [V3SearchResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SearchResult]> in
            return Decoders.decode(clazz: [V3SearchResult].self, source: source)
        }

        // Decoder for V3SearchResult
        Decoders.addDecoder(clazz: V3SearchResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SearchResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SearchResult() : instance as! V3SearchResult
                switch Decoders.decodeOptional(clazz: [V3ResultStop].self, source: sourceDictionary["stops"] as AnyObject?) {
                case let .success(value): _result.stops = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3ResultRoute].self, source: sourceDictionary["routes"] as AnyObject?) {
                case let .success(value): _result.routes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3ResultOutlet].self, source: sourceDictionary["outlets"] as AnyObject?) {
                case let .success(value): _result.outlets = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SearchResult", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriDirectionRefsDictionary]
        Decoders.addDecoder(clazz: [V3SiriDirectionRefsDictionary].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriDirectionRefsDictionary]> in
            return Decoders.decode(clazz: [V3SiriDirectionRefsDictionary].self, source: source)
        }

        // Decoder for V3SiriDirectionRefsDictionary
        Decoders.addDecoder(clazz: V3SiriDirectionRefsDictionary.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriDirectionRefsDictionary> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriDirectionRefsDictionary() : instance as! V3SiriDirectionRefsDictionary
                switch Decoders.decodeOptional(clazz: [String:V3SiriStopsRefsDictionary].self, source: sourceDictionary["direction_refs"] as AnyObject?) {
                case let .success(value): _result.directionRefs = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriDirectionRefsDictionary", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriDownstreamSubscription]
        Decoders.addDecoder(clazz: [V3SiriDownstreamSubscription].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriDownstreamSubscription]> in
            return Decoders.decode(clazz: [V3SiriDownstreamSubscription].self, source: source)
        }

        // Decoder for V3SiriDownstreamSubscription
        Decoders.addDecoder(clazz: V3SiriDownstreamSubscription.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriDownstreamSubscription> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriDownstreamSubscription() : instance as! V3SiriDownstreamSubscription
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subscriber_ref"] as AnyObject?) {
                case let .success(value): _result.subscriberRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subscription_ref"] as AnyObject?) {
                case let .success(value): _result.subscriptionRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3SiriDownstreamSubscription.MessageType.self, source: sourceDictionary["message_type"] as AnyObject?) {
                case let .success(value): _result.messageType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3SiriDownstreamSubscription.SiriFormat.self, source: sourceDictionary["siri_format"] as AnyObject?) {
                case let .success(value): _result.siriFormat = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["siri_version"] as AnyObject?) {
                case let .success(value): _result.siriVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["consumer_address"] as AnyObject?) {
                case let .success(value): _result.consumerAddress = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["initial_termination_time"] as AnyObject?) {
                case let .success(value): _result.initialTerminationTime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["validity_period_start"] as AnyObject?) {
                case let .success(value): _result.validityPeriodStart = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["validity_period_end"] as AnyObject?) {
                case let .success(value): _result.validityPeriodEnd = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preview_interval"] as AnyObject?) {
                case let .success(value): _result.previewInterval = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3SiriDownstreamSubscriptionTopic].self, source: sourceDictionary["topics"] as AnyObject?) {
                case let .success(value): _result.topics = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriDownstreamSubscription", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriDownstreamSubscriptionDeleteRequest]
        Decoders.addDecoder(clazz: [V3SiriDownstreamSubscriptionDeleteRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriDownstreamSubscriptionDeleteRequest]> in
            return Decoders.decode(clazz: [V3SiriDownstreamSubscriptionDeleteRequest].self, source: source)
        }

        // Decoder for V3SiriDownstreamSubscriptionDeleteRequest
        Decoders.addDecoder(clazz: V3SiriDownstreamSubscriptionDeleteRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriDownstreamSubscriptionDeleteRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriDownstreamSubscriptionDeleteRequest() : instance as! V3SiriDownstreamSubscriptionDeleteRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subscriber_ref"] as AnyObject?) {
                case let .success(value): _result.subscriberRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["subscription_ref"] as AnyObject?) {
                case let .success(value): _result.subscriptionRef = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriDownstreamSubscriptionDeleteRequest", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriDownstreamSubscriptionResponse]
        Decoders.addDecoder(clazz: [V3SiriDownstreamSubscriptionResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriDownstreamSubscriptionResponse]> in
            return Decoders.decode(clazz: [V3SiriDownstreamSubscriptionResponse].self, source: source)
        }

        // Decoder for V3SiriDownstreamSubscriptionResponse
        Decoders.addDecoder(clazz: V3SiriDownstreamSubscriptionResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriDownstreamSubscriptionResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriDownstreamSubscriptionResponse() : instance as! V3SiriDownstreamSubscriptionResponse
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["valid_until"] as AnyObject?) {
                case let .success(value): _result.validUntil = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriDownstreamSubscriptionResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriDownstreamSubscriptionTopic]
        Decoders.addDecoder(clazz: [V3SiriDownstreamSubscriptionTopic].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriDownstreamSubscriptionTopic]> in
            return Decoders.decode(clazz: [V3SiriDownstreamSubscriptionTopic].self, source: source)
        }

        // Decoder for V3SiriDownstreamSubscriptionTopic
        Decoders.addDecoder(clazz: V3SiriDownstreamSubscriptionTopic.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriDownstreamSubscriptionTopic> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriDownstreamSubscriptionTopic() : instance as! V3SiriDownstreamSubscriptionTopic
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["line_ref"] as AnyObject?) {
                case let .success(value): _result.lineRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3SiriDownstreamSubscriptionTopic.DirectionRef.self, source: sourceDictionary["direction_ref"] as AnyObject?) {
                case let .success(value): _result.directionRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3SiriDownstreamSubscriptionTopic.RouteType.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriDownstreamSubscriptionTopic", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriEstimatedTimetableSubscriptionRequest]
        Decoders.addDecoder(clazz: [V3SiriEstimatedTimetableSubscriptionRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriEstimatedTimetableSubscriptionRequest]> in
            return Decoders.decode(clazz: [V3SiriEstimatedTimetableSubscriptionRequest].self, source: source)
        }

        // Decoder for V3SiriEstimatedTimetableSubscriptionRequest
        Decoders.addDecoder(clazz: V3SiriEstimatedTimetableSubscriptionRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriEstimatedTimetableSubscriptionRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriEstimatedTimetableSubscriptionRequest() : instance as! V3SiriEstimatedTimetableSubscriptionRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preview_interval"] as AnyObject?) {
                case let .success(value): _result.previewInterval = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subscriber_ref"] as AnyObject?) {
                case let .success(value): _result.subscriberRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subscription_ref"] as AnyObject?) {
                case let .success(value): _result.subscriptionRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3SiriEstimatedTimetableSubscriptionRequest.SiriFormat.self, source: sourceDictionary["siri_format"] as AnyObject?) {
                case let .success(value): _result.siriFormat = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["siri_version"] as AnyObject?) {
                case let .success(value): _result.siriVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["consumer_address"] as AnyObject?) {
                case let .success(value): _result.consumerAddress = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["initial_termination_time"] as AnyObject?) {
                case let .success(value): _result.initialTerminationTime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3SiriSubscriptionTopic].self, source: sourceDictionary["topics"] as AnyObject?) {
                case let .success(value): _result.topics = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriEstimatedTimetableSubscriptionRequest", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriLineRef]
        Decoders.addDecoder(clazz: [V3SiriLineRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriLineRef]> in
            return Decoders.decode(clazz: [V3SiriLineRef].self, source: source)
        }

        // Decoder for V3SiriLineRef
        Decoders.addDecoder(clazz: V3SiriLineRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriLineRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriLineRef() : instance as! V3SiriLineRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["line_ref"] as AnyObject?) {
                case let .success(value): _result.lineRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3SiriLineRef.DirectionRef.self, source: sourceDictionary["direction_ref"] as AnyObject?) {
                case let .success(value): _result.directionRef = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriLineRef", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriLineRefDirectionRefStopPointRef]
        Decoders.addDecoder(clazz: [V3SiriLineRefDirectionRefStopPointRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriLineRefDirectionRefStopPointRef]> in
            return Decoders.decode(clazz: [V3SiriLineRefDirectionRefStopPointRef].self, source: source)
        }

        // Decoder for V3SiriLineRefDirectionRefStopPointRef
        Decoders.addDecoder(clazz: V3SiriLineRefDirectionRefStopPointRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriLineRefDirectionRefStopPointRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriLineRefDirectionRefStopPointRef() : instance as! V3SiriLineRefDirectionRefStopPointRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["line_ref"] as AnyObject?) {
                case let .success(value): _result.lineRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3SiriLineRefDirectionRefStopPointRef.DirectionRef.self, source: sourceDictionary["direction_ref"] as AnyObject?) {
                case let .success(value): _result.directionRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_point_ref"] as AnyObject?) {
                case let .success(value): _result.stopPointRef = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriLineRefDirectionRefStopPointRef", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriLineRefDirectionRefsDictionary]
        Decoders.addDecoder(clazz: [V3SiriLineRefDirectionRefsDictionary].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriLineRefDirectionRefsDictionary]> in
            return Decoders.decode(clazz: [V3SiriLineRefDirectionRefsDictionary].self, source: source)
        }

        // Decoder for V3SiriLineRefDirectionRefsDictionary
        Decoders.addDecoder(clazz: V3SiriLineRefDirectionRefsDictionary.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriLineRefDirectionRefsDictionary> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriLineRefDirectionRefsDictionary() : instance as! V3SiriLineRefDirectionRefsDictionary
                switch Decoders.decodeOptional(clazz: [String:[V3SiriReferenceDataDetail]].self, source: sourceDictionary["direction_refs"] as AnyObject?) {
                case let .success(value): _result.directionRefs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["unmatched_direction_refs"] as AnyObject?) {
                case let .success(value): _result.unmatchedDirectionRefs = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriLineRefDirectionRefsDictionary", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriLineRefMappingsResponse]
        Decoders.addDecoder(clazz: [V3SiriLineRefMappingsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriLineRefMappingsResponse]> in
            return Decoders.decode(clazz: [V3SiriLineRefMappingsResponse].self, source: source)
        }

        // Decoder for V3SiriLineRefMappingsResponse
        Decoders.addDecoder(clazz: V3SiriLineRefMappingsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriLineRefMappingsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriLineRefMappingsResponse() : instance as! V3SiriLineRefMappingsResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mapping_version"] as AnyObject?) {
                case let .success(value): _result.mappingVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3SiriLineRefDirectionRefsDictionary].self, source: sourceDictionary["line_refs"] as AnyObject?) {
                case let .success(value): _result.lineRefs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriLineRefMappingsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriLineRefsRequest]
        Decoders.addDecoder(clazz: [V3SiriLineRefsRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriLineRefsRequest]> in
            return Decoders.decode(clazz: [V3SiriLineRefsRequest].self, source: source)
        }

        // Decoder for V3SiriLineRefsRequest
        Decoders.addDecoder(clazz: V3SiriLineRefsRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriLineRefsRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriLineRefsRequest() : instance as! V3SiriLineRefsRequest
                switch Decoders.decodeOptional(clazz: [V3SiriLineRef].self, source: sourceDictionary["line_refs"] as AnyObject?) {
                case let .success(value): _result.lineRefs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mapping_version"] as AnyObject?) {
                case let .success(value): _result.mappingVersion = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriLineRefsRequest", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriProductionTimetableSubscriptionRequest]
        Decoders.addDecoder(clazz: [V3SiriProductionTimetableSubscriptionRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriProductionTimetableSubscriptionRequest]> in
            return Decoders.decode(clazz: [V3SiriProductionTimetableSubscriptionRequest].self, source: source)
        }

        // Decoder for V3SiriProductionTimetableSubscriptionRequest
        Decoders.addDecoder(clazz: V3SiriProductionTimetableSubscriptionRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriProductionTimetableSubscriptionRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriProductionTimetableSubscriptionRequest() : instance as! V3SiriProductionTimetableSubscriptionRequest
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["start_time"] as AnyObject?) {
                case let .success(value): _result.startTime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["end_time"] as AnyObject?) {
                case let .success(value): _result.endTime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subscriber_ref"] as AnyObject?) {
                case let .success(value): _result.subscriberRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subscription_ref"] as AnyObject?) {
                case let .success(value): _result.subscriptionRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3SiriProductionTimetableSubscriptionRequest.SiriFormat.self, source: sourceDictionary["siri_format"] as AnyObject?) {
                case let .success(value): _result.siriFormat = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["siri_version"] as AnyObject?) {
                case let .success(value): _result.siriVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["consumer_address"] as AnyObject?) {
                case let .success(value): _result.consumerAddress = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["initial_termination_time"] as AnyObject?) {
                case let .success(value): _result.initialTerminationTime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3SiriSubscriptionTopic].self, source: sourceDictionary["topics"] as AnyObject?) {
                case let .success(value): _result.topics = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriProductionTimetableSubscriptionRequest", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriReferenceDataDetail]
        Decoders.addDecoder(clazz: [V3SiriReferenceDataDetail].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriReferenceDataDetail]> in
            return Decoders.decode(clazz: [V3SiriReferenceDataDetail].self, source: source)
        }

        // Decoder for V3SiriReferenceDataDetail
        Decoders.addDecoder(clazz: V3SiriReferenceDataDetail.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriReferenceDataDetail> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriReferenceDataDetail() : instance as! V3SiriReferenceDataDetail
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_number_short"] as AnyObject?) {
                case let .success(value): _result.routeNumberShort = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["tracking_supplier_id"] as AnyObject?) {
                case let .success(value): _result.trackingSupplierId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriReferenceDataDetail", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriReferenceDataMappingsResponse]
        Decoders.addDecoder(clazz: [V3SiriReferenceDataMappingsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriReferenceDataMappingsResponse]> in
            return Decoders.decode(clazz: [V3SiriReferenceDataMappingsResponse].self, source: source)
        }

        // Decoder for V3SiriReferenceDataMappingsResponse
        Decoders.addDecoder(clazz: V3SiriReferenceDataMappingsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriReferenceDataMappingsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriReferenceDataMappingsResponse() : instance as! V3SiriReferenceDataMappingsResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mapping_version"] as AnyObject?) {
                case let .success(value): _result.mappingVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3SiriDirectionRefsDictionary].self, source: sourceDictionary["line_refs"] as AnyObject?) {
                case let .success(value): _result.lineRefs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3StopPoint].self, source: sourceDictionary["stop_point_refs"] as AnyObject?) {
                case let .success(value): _result.stopPointRefs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriReferenceDataMappingsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriReferenceDataRequest]
        Decoders.addDecoder(clazz: [V3SiriReferenceDataRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriReferenceDataRequest]> in
            return Decoders.decode(clazz: [V3SiriReferenceDataRequest].self, source: source)
        }

        // Decoder for V3SiriReferenceDataRequest
        Decoders.addDecoder(clazz: V3SiriReferenceDataRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriReferenceDataRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriReferenceDataRequest() : instance as! V3SiriReferenceDataRequest
                switch Decoders.decodeOptional(clazz: [V3SiriLineRefDirectionRefStopPointRef].self, source: sourceDictionary["line_refs"] as AnyObject?) {
                case let .success(value): _result.lineRefs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["stop_point_refs"] as AnyObject?) {
                case let .success(value): _result.stopPointRefs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["date_utc"] as AnyObject?) {
                case let .success(value): _result.dateUtc = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mapping_version"] as AnyObject?) {
                case let .success(value): _result.mappingVersion = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriReferenceDataRequest", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriStopsRefsDictionary]
        Decoders.addDecoder(clazz: [V3SiriStopsRefsDictionary].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriStopsRefsDictionary]> in
            return Decoders.decode(clazz: [V3SiriStopsRefsDictionary].self, source: source)
        }

        // Decoder for V3SiriStopsRefsDictionary
        Decoders.addDecoder(clazz: V3SiriStopsRefsDictionary.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriStopsRefsDictionary> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriStopsRefsDictionary() : instance as! V3SiriStopsRefsDictionary
                switch Decoders.decodeOptional(clazz: [String:V3SiriReferenceDataDetail].self, source: sourceDictionary["stop_point_refs"] as AnyObject?) {
                case let .success(value): _result.stopPointRefs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["unmatched_stop_point_refs"] as AnyObject?) {
                case let .success(value): _result.unmatchedStopPointRefs = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriStopsRefsDictionary", actual: "\(source)"))
            }
        }
        // Decoder for [V3SiriSubscriptionTopic]
        Decoders.addDecoder(clazz: [V3SiriSubscriptionTopic].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3SiriSubscriptionTopic]> in
            return Decoders.decode(clazz: [V3SiriSubscriptionTopic].self, source: source)
        }

        // Decoder for V3SiriSubscriptionTopic
        Decoders.addDecoder(clazz: V3SiriSubscriptionTopic.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3SiriSubscriptionTopic> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3SiriSubscriptionTopic() : instance as! V3SiriSubscriptionTopic
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["line_ref"] as AnyObject?) {
                case let .success(value): _result.lineRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3SiriSubscriptionTopic.DirectionRef.self, source: sourceDictionary["direction_ref"] as AnyObject?) {
                case let .success(value): _result.directionRef = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3SiriSubscriptionTopic.RouteType.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3SiriSubscriptionTopic", actual: "\(source)"))
            }
        }
        // Decoder for [V3Status]
        Decoders.addDecoder(clazz: [V3Status].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3Status]> in
            return Decoders.decode(clazz: [V3Status].self, source: source)
        }

        // Decoder for V3Status
        Decoders.addDecoder(clazz: V3Status.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3Status> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3Status() : instance as! V3Status
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.Health.self, source: sourceDictionary["health"] as AnyObject?) {
                case let .success(value): _result.health = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3Status", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopAccessibility]
        Decoders.addDecoder(clazz: [V3StopAccessibility].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopAccessibility]> in
            return Decoders.decode(clazz: [V3StopAccessibility].self, source: source)
        }

        // Decoder for V3StopAccessibility
        Decoders.addDecoder(clazz: V3StopAccessibility.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopAccessibility> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopAccessibility() : instance as! V3StopAccessibility
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["lighting"] as AnyObject?) {
                case let .success(value): _result.lighting = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["platform_number"] as AnyObject?) {
                case let .success(value): _result.platformNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["audio_customer_information"] as AnyObject?) {
                case let .success(value): _result.audioCustomerInformation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["escalator"] as AnyObject?) {
                case let .success(value): _result.escalator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["hearing_loop"] as AnyObject?) {
                case let .success(value): _result.hearingLoop = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["lift"] as AnyObject?) {
                case let .success(value): _result.lift = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["stairs"] as AnyObject?) {
                case let .success(value): _result.stairs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["stop_accessible"] as AnyObject?) {
                case let .success(value): _result.stopAccessible = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["tactile_ground_surface_indicator"] as AnyObject?) {
                case let .success(value): _result.tactileGroundSurfaceIndicator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["waiting_room"] as AnyObject?) {
                case let .success(value): _result.waitingRoom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3StopAccessibilityWheelchair.self, source: sourceDictionary["wheelchair"] as AnyObject?) {
                case let .success(value): _result.wheelchair = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopAccessibility", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopAccessibilityWheelchair]
        Decoders.addDecoder(clazz: [V3StopAccessibilityWheelchair].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopAccessibilityWheelchair]> in
            return Decoders.decode(clazz: [V3StopAccessibilityWheelchair].self, source: source)
        }

        // Decoder for V3StopAccessibilityWheelchair
        Decoders.addDecoder(clazz: V3StopAccessibilityWheelchair.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopAccessibilityWheelchair> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopAccessibilityWheelchair() : instance as! V3StopAccessibilityWheelchair
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["accessible_ramp"] as AnyObject?) {
                case let .success(value): _result.accessibleRamp = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["parking"] as AnyObject?) {
                case let .success(value): _result.parking = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["telephone"] as AnyObject?) {
                case let .success(value): _result.telephone = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["toilet"] as AnyObject?) {
                case let .success(value): _result.toilet = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["low_ticket_counter"] as AnyObject?) {
                case let .success(value): _result.lowTicketCounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["manouvering"] as AnyObject?) {
                case let .success(value): _result.manouvering = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["raised_platform"] as AnyObject?) {
                case let .success(value): _result.raisedPlatform = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["ramp"] as AnyObject?) {
                case let .success(value): _result.ramp = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["secondary_path"] as AnyObject?) {
                case let .success(value): _result.secondaryPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["raised_platform_shelther"] as AnyObject?) {
                case let .success(value): _result.raisedPlatformShelther = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["steep_ramp"] as AnyObject?) {
                case let .success(value): _result.steepRamp = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopAccessibilityWheelchair", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopAmenityDetails]
        Decoders.addDecoder(clazz: [V3StopAmenityDetails].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopAmenityDetails]> in
            return Decoders.decode(clazz: [V3StopAmenityDetails].self, source: source)
        }

        // Decoder for V3StopAmenityDetails
        Decoders.addDecoder(clazz: V3StopAmenityDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopAmenityDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopAmenityDetails() : instance as! V3StopAmenityDetails
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["toilet"] as AnyObject?) {
                case let .success(value): _result.toilet = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["taxi_rank"] as AnyObject?) {
                case let .success(value): _result.taxiRank = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["car_parking"] as AnyObject?) {
                case let .success(value): _result.carParking = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["cctv"] as AnyObject?) {
                case let .success(value): _result.cctv = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopAmenityDetails", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopBasic]
        Decoders.addDecoder(clazz: [V3StopBasic].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopBasic]> in
            return Decoders.decode(clazz: [V3StopBasic].self, source: source)
        }

        // Decoder for V3StopBasic
        Decoders.addDecoder(clazz: V3StopBasic.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopBasic> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopBasic() : instance as! V3StopBasic
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_name"] as AnyObject?) {
                case let .success(value): _result.stopName = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopBasic", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopDepartureRequest]
        Decoders.addDecoder(clazz: [V3StopDepartureRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopDepartureRequest]> in
            return Decoders.decode(clazz: [V3StopDepartureRequest].self, source: source)
        }

        // Decoder for V3StopDepartureRequest
        Decoders.addDecoder(clazz: V3StopDepartureRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopDepartureRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopDepartureRequest() : instance as! V3StopDepartureRequest
                switch Decoders.decodeOptional(clazz: V3StopDepartureRequest.RouteType.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_results"] as AnyObject?) {
                case let .success(value): _result.maxResults = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["gtfs"] as AnyObject?) {
                case let .success(value): _result.gtfs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3StopDepartureRequestRouteDirection].self, source: sourceDictionary["route_directions"] as AnyObject?) {
                case let .success(value): _result.routeDirections = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopDepartureRequest", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopDepartureRequestRouteDirection]
        Decoders.addDecoder(clazz: [V3StopDepartureRequestRouteDirection].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopDepartureRequestRouteDirection]> in
            return Decoders.decode(clazz: [V3StopDepartureRequestRouteDirection].self, source: source)
        }

        // Decoder for V3StopDepartureRequestRouteDirection
        Decoders.addDecoder(clazz: V3StopDepartureRequestRouteDirection.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopDepartureRequestRouteDirection> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopDepartureRequestRouteDirection() : instance as! V3StopDepartureRequestRouteDirection
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route_id"] as AnyObject?) {
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["direction_id"] as AnyObject?) {
                case let .success(value): _result.directionId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["direction_name"] as AnyObject?) {
                case let .success(value): _result.directionName = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopDepartureRequestRouteDirection", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopDetails]
        Decoders.addDecoder(clazz: [V3StopDetails].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopDetails]> in
            return Decoders.decode(clazz: [V3StopDetails].self, source: source)
        }

        // Decoder for V3StopDetails
        Decoders.addDecoder(clazz: V3StopDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopDetails() : instance as! V3StopDetails
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["disruption_ids"] as AnyObject?) {
                case let .success(value): _result.disruptionIds = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["station_type"] as AnyObject?) {
                case let .success(value): _result.stationType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["station_description"] as AnyObject?) {
                case let .success(value): _result.stationDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3StopLocation.self, source: sourceDictionary["stop_location"] as AnyObject?) {
                case let .success(value): _result.stopLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3StopAmenityDetails.self, source: sourceDictionary["stop_amenities"] as AnyObject?) {
                case let .success(value): _result.stopAmenities = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3StopAccessibility.self, source: sourceDictionary["stop_accessibility"] as AnyObject?) {
                case let .success(value): _result.stopAccessibility = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3StopStaffing.self, source: sourceDictionary["stop_staffing"] as AnyObject?) {
                case let .success(value): _result.stopStaffing = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["routes"] as AnyObject?) {
                case let .success(value): _result.routes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_name"] as AnyObject?) {
                case let .success(value): _result.stopName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_landmark"] as AnyObject?) {
                case let .success(value): _result.stopLandmark = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopDetails", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopGeosearch]
        Decoders.addDecoder(clazz: [V3StopGeosearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopGeosearch]> in
            return Decoders.decode(clazz: [V3StopGeosearch].self, source: source)
        }

        // Decoder for V3StopGeosearch
        Decoders.addDecoder(clazz: V3StopGeosearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopGeosearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopGeosearch() : instance as! V3StopGeosearch
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["disruption_ids"] as AnyObject?) {
                case let .success(value): _result.disruptionIds = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_distance"] as AnyObject?) {
                case let .success(value): _result.stopDistance = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_suburb"] as AnyObject?) {
                case let .success(value): _result.stopSuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_name"] as AnyObject?) {
                case let .success(value): _result.stopName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["routes"] as AnyObject?) {
                case let .success(value): _result.routes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_latitude"] as AnyObject?) {
                case let .success(value): _result.stopLatitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_longitude"] as AnyObject?) {
                case let .success(value): _result.stopLongitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_landmark"] as AnyObject?) {
                case let .success(value): _result.stopLandmark = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_sequence"] as AnyObject?) {
                case let .success(value): _result.stopSequence = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopGeosearch", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopGps]
        Decoders.addDecoder(clazz: [V3StopGps].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopGps]> in
            return Decoders.decode(clazz: [V3StopGps].self, source: source)
        }

        // Decoder for V3StopGps
        Decoders.addDecoder(clazz: V3StopGps.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopGps> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopGps() : instance as! V3StopGps
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopGps", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopLocation]
        Decoders.addDecoder(clazz: [V3StopLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopLocation]> in
            return Decoders.decode(clazz: [V3StopLocation].self, source: source)
        }

        // Decoder for V3StopLocation
        Decoders.addDecoder(clazz: V3StopLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopLocation() : instance as! V3StopLocation
                switch Decoders.decodeOptional(clazz: V3StopGps.self, source: sourceDictionary["gps"] as AnyObject?) {
                case let .success(value): _result.gps = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopLocation", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopModel]
        Decoders.addDecoder(clazz: [V3StopModel].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopModel]> in
            return Decoders.decode(clazz: [V3StopModel].self, source: source)
        }

        // Decoder for V3StopModel
        Decoders.addDecoder(clazz: V3StopModel.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopModel> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopModel() : instance as! V3StopModel
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_distance"] as AnyObject?) {
                case let .success(value): _result.stopDistance = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_suburb"] as AnyObject?) {
                case let .success(value): _result.stopSuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_name"] as AnyObject?) {
                case let .success(value): _result.stopName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_latitude"] as AnyObject?) {
                case let .success(value): _result.stopLatitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_longitude"] as AnyObject?) {
                case let .success(value): _result.stopLongitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_landmark"] as AnyObject?) {
                case let .success(value): _result.stopLandmark = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_sequence"] as AnyObject?) {
                case let .success(value): _result.stopSequence = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopModel", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopOnRoute]
        Decoders.addDecoder(clazz: [V3StopOnRoute].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopOnRoute]> in
            return Decoders.decode(clazz: [V3StopOnRoute].self, source: source)
        }

        // Decoder for V3StopOnRoute
        Decoders.addDecoder(clazz: V3StopOnRoute.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopOnRoute> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopOnRoute() : instance as! V3StopOnRoute
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["disruption_ids"] as AnyObject?) {
                case let .success(value): _result.disruptionIds = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_suburb"] as AnyObject?) {
                case let .success(value): _result.stopSuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_latitude"] as AnyObject?) {
                case let .success(value): _result.stopLatitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_longitude"] as AnyObject?) {
                case let .success(value): _result.stopLongitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_sequence"] as AnyObject?) {
                case let .success(value): _result.stopSequence = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3StopTicket.self, source: sourceDictionary["stop_ticket"] as AnyObject?) {
                case let .success(value): _result.stopTicket = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_name"] as AnyObject?) {
                case let .success(value): _result.stopName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_landmark"] as AnyObject?) {
                case let .success(value): _result.stopLandmark = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopOnRoute", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopPoint]
        Decoders.addDecoder(clazz: [V3StopPoint].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopPoint]> in
            return Decoders.decode(clazz: [V3StopPoint].self, source: source)
        }

        // Decoder for V3StopPoint
        Decoders.addDecoder(clazz: V3StopPoint.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopPoint> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopPoint() : instance as! V3StopPoint
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopPoint", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopResponse]
        Decoders.addDecoder(clazz: [V3StopResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopResponse]> in
            return Decoders.decode(clazz: [V3StopResponse].self, source: source)
        }

        // Decoder for V3StopResponse
        Decoders.addDecoder(clazz: V3StopResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopResponse() : instance as! V3StopResponse
                switch Decoders.decodeOptional(clazz: V3StopDetails.self, source: sourceDictionary["stop"] as AnyObject?) {
                case let .success(value): _result.stop = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3Disruption].self, source: sourceDictionary["disruptions"] as AnyObject?) {
                case let .success(value): _result.disruptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopStaffing]
        Decoders.addDecoder(clazz: [V3StopStaffing].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopStaffing]> in
            return Decoders.decode(clazz: [V3StopStaffing].self, source: source)
        }

        // Decoder for V3StopStaffing
        Decoders.addDecoder(clazz: V3StopStaffing.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopStaffing> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopStaffing() : instance as! V3StopStaffing
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fri_am_from"] as AnyObject?) {
                case let .success(value): _result.friAmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fri_am_to"] as AnyObject?) {
                case let .success(value): _result.friAmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fri_pm_from"] as AnyObject?) {
                case let .success(value): _result.friPmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fri_pm_to"] as AnyObject?) {
                case let .success(value): _result.friPmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mon_am_from"] as AnyObject?) {
                case let .success(value): _result.monAmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mon_am_to"] as AnyObject?) {
                case let .success(value): _result.monAmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mon_pm_from"] as AnyObject?) {
                case let .success(value): _result.monPmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mon_pm_to"] as AnyObject?) {
                case let .success(value): _result.monPmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ph_additional_text"] as AnyObject?) {
                case let .success(value): _result.phAdditionalText = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ph_from"] as AnyObject?) {
                case let .success(value): _result.phFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ph_to"] as AnyObject?) {
                case let .success(value): _result.phTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sat_am_from"] as AnyObject?) {
                case let .success(value): _result.satAmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sat_am_to"] as AnyObject?) {
                case let .success(value): _result.satAmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sat_pm_from"] as AnyObject?) {
                case let .success(value): _result.satPmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sat_pm_to"] as AnyObject?) {
                case let .success(value): _result.satPmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sun_am_from"] as AnyObject?) {
                case let .success(value): _result.sunAmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sun_am_to"] as AnyObject?) {
                case let .success(value): _result.sunAmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sun_pm_from"] as AnyObject?) {
                case let .success(value): _result.sunPmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sun_pm_to"] as AnyObject?) {
                case let .success(value): _result.sunPmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["thu_am_from"] as AnyObject?) {
                case let .success(value): _result.thuAmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["thu_am_to"] as AnyObject?) {
                case let .success(value): _result.thuAmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["thu_pm_from"] as AnyObject?) {
                case let .success(value): _result.thuPmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["thu_pm_to"] as AnyObject?) {
                case let .success(value): _result.thuPmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tue_am_from"] as AnyObject?) {
                case let .success(value): _result.tueAmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tue_am_to"] as AnyObject?) {
                case let .success(value): _result.tueAmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tue_pm_from"] as AnyObject?) {
                case let .success(value): _result.tuePmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tue_pm_to"] as AnyObject?) {
                case let .success(value): _result.tuePmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["wed_am_from"] as AnyObject?) {
                case let .success(value): _result.wedAmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["wed_am_to"] as AnyObject?) {
                case let .success(value): _result.wedAmTo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["wed_pm_from"] as AnyObject?) {
                case let .success(value): _result.wedPmFrom = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["wed_pm_To"] as AnyObject?) {
                case let .success(value): _result.wedPmTo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopStaffing", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopTicket]
        Decoders.addDecoder(clazz: [V3StopTicket].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopTicket]> in
            return Decoders.decode(clazz: [V3StopTicket].self, source: source)
        }

        // Decoder for V3StopTicket
        Decoders.addDecoder(clazz: V3StopTicket.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopTicket> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopTicket() : instance as! V3StopTicket
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ticket_type"] as AnyObject?) {
                case let .success(value): _result.ticketType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["zone"] as AnyObject?) {
                case let .success(value): _result.zone = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["is_free_fare_zone"] as AnyObject?) {
                case let .success(value): _result.isFreeFareZone = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["ticket_machine"] as AnyObject?) {
                case let .success(value): _result.ticketMachine = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["ticket_checks"] as AnyObject?) {
                case let .success(value): _result.ticketChecks = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["vline_reservation"] as AnyObject?) {
                case let .success(value): _result.vlineReservation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["ticket_zones"] as AnyObject?) {
                case let .success(value): _result.ticketZones = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopTicket", actual: "\(source)"))
            }
        }
        // Decoder for [V3StoppingPattern]
        Decoders.addDecoder(clazz: [V3StoppingPattern].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StoppingPattern]> in
            return Decoders.decode(clazz: [V3StoppingPattern].self, source: source)
        }

        // Decoder for V3StoppingPattern
        Decoders.addDecoder(clazz: V3StoppingPattern.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StoppingPattern> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StoppingPattern() : instance as! V3StoppingPattern
                switch Decoders.decodeOptional(clazz: [V3Disruption].self, source: sourceDictionary["disruptions"] as AnyObject?) {
                case let .success(value): _result.disruptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [V3PatternDeparture].self, source: sourceDictionary["departures"] as AnyObject?) {
                case let .success(value): _result.departures = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3StoppingPatternStop].self, source: sourceDictionary["stops"] as AnyObject?) {
                case let .success(value): _result.stops = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:Any].self, source: sourceDictionary["routes"] as AnyObject?) {
                case let .success(value): _result.routes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3Run].self, source: sourceDictionary["runs"] as AnyObject?) {
                case let .success(value): _result.runs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3Direction].self, source: sourceDictionary["directions"] as AnyObject?) {
                case let .success(value): _result.directions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StoppingPattern", actual: "\(source)"))
            }
        }
        // Decoder for [V3StoppingPatternStop]
        Decoders.addDecoder(clazz: [V3StoppingPatternStop].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StoppingPatternStop]> in
            return Decoders.decode(clazz: [V3StoppingPatternStop].self, source: source)
        }

        // Decoder for V3StoppingPatternStop
        Decoders.addDecoder(clazz: V3StoppingPatternStop.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StoppingPatternStop> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StoppingPatternStop() : instance as! V3StoppingPatternStop
                switch Decoders.decodeOptional(clazz: V3StopTicket.self, source: sourceDictionary["stop_ticket"] as AnyObject?) {
                case let .success(value): _result.stopTicket = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_distance"] as AnyObject?) {
                case let .success(value): _result.stopDistance = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_suburb"] as AnyObject?) {
                case let .success(value): _result.stopSuburb = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_name"] as AnyObject?) {
                case let .success(value): _result.stopName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_id"] as AnyObject?) {
                case let .success(value): _result.stopId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["route_type"] as AnyObject?) {
                case let .success(value): _result.routeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_latitude"] as AnyObject?) {
                case let .success(value): _result.stopLatitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["stop_longitude"] as AnyObject?) {
                case let .success(value): _result.stopLongitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stop_landmark"] as AnyObject?) {
                case let .success(value): _result.stopLandmark = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stop_sequence"] as AnyObject?) {
                case let .success(value): _result.stopSequence = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StoppingPatternStop", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopsByDistanceResponse]
        Decoders.addDecoder(clazz: [V3StopsByDistanceResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopsByDistanceResponse]> in
            return Decoders.decode(clazz: [V3StopsByDistanceResponse].self, source: source)
        }

        // Decoder for V3StopsByDistanceResponse
        Decoders.addDecoder(clazz: V3StopsByDistanceResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopsByDistanceResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopsByDistanceResponse() : instance as! V3StopsByDistanceResponse
                switch Decoders.decodeOptional(clazz: [V3StopGeosearch].self, source: sourceDictionary["stops"] as AnyObject?) {
                case let .success(value): _result.stops = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3Disruption].self, source: sourceDictionary["disruptions"] as AnyObject?) {
                case let .success(value): _result.disruptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopsByDistanceResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3StopsOnRouteResponse]
        Decoders.addDecoder(clazz: [V3StopsOnRouteResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3StopsOnRouteResponse]> in
            return Decoders.decode(clazz: [V3StopsOnRouteResponse].self, source: source)
        }

        // Decoder for V3StopsOnRouteResponse
        Decoders.addDecoder(clazz: V3StopsOnRouteResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3StopsOnRouteResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3StopsOnRouteResponse() : instance as! V3StopsOnRouteResponse
                switch Decoders.decodeOptional(clazz: [V3StopOnRoute].self, source: sourceDictionary["stops"] as AnyObject?) {
                case let .success(value): _result.stops = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:V3Disruption].self, source: sourceDictionary["disruptions"] as AnyObject?) {
                case let .success(value): _result.disruptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["geopath"] as AnyObject?) {
                case let .success(value): _result.geopath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: V3Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3StopsOnRouteResponse", actual: "\(source)"))
            }
        }
        // Decoder for [V3VehicleDescriptor]
        Decoders.addDecoder(clazz: [V3VehicleDescriptor].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3VehicleDescriptor]> in
            return Decoders.decode(clazz: [V3VehicleDescriptor].self, source: source)
        }

        // Decoder for V3VehicleDescriptor
        Decoders.addDecoder(clazz: V3VehicleDescriptor.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3VehicleDescriptor> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3VehicleDescriptor() : instance as! V3VehicleDescriptor
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                case let .success(value): _result.id = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["low_floor"] as AnyObject?) {
                case let .success(value): _result.lowFloor = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["air_conditioned"] as AnyObject?) {
                case let .success(value): _result.airConditioned = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["supplier"] as AnyObject?) {
                case let .success(value): _result.supplier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["length"] as AnyObject?) {
                case let .success(value): _result.length = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3VehicleDescriptor", actual: "\(source)"))
            }
        }
        // Decoder for [V3VehiclePosition]
        Decoders.addDecoder(clazz: [V3VehiclePosition].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3VehiclePosition]> in
            return Decoders.decode(clazz: [V3VehiclePosition].self, source: source)
        }

        // Decoder for V3VehiclePosition
        Decoders.addDecoder(clazz: V3VehiclePosition.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3VehiclePosition> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3VehiclePosition() : instance as! V3VehiclePosition
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["easting"] as AnyObject?) {
                case let .success(value): _result.easting = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["northing"] as AnyObject?) {
                case let .success(value): _result.northing = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["direction"] as AnyObject?) {
                case let .success(value): _result.direction = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["bearing"] as AnyObject?) {
                case let .success(value): _result.bearing = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["supplier"] as AnyObject?) {
                case let .success(value): _result.supplier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["datetime_utc"] as AnyObject?) {
                case let .success(value): _result.datetimeUtc = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["expiry_time"] as AnyObject?) {
                case let .success(value): _result.expiryTime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3VehiclePosition", actual: "\(source)"))
            }
        }
        // Decoder for [V3Void]
        Decoders.addDecoder(clazz: [V3Void].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3Void]> in
            return Decoders.decode(clazz: [V3Void].self, source: source)
        }

        // Decoder for V3Void
        Decoders.addDecoder(clazz: V3Void.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3Void> in
            if let source = source as? V3Void {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias V3Void", actual: "\(source)"))
            }
        }
        // Decoder for [V3ZoneInfo]
        Decoders.addDecoder(clazz: [V3ZoneInfo].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[V3ZoneInfo]> in
            return Decoders.decode(clazz: [V3ZoneInfo].self, source: source)
        }

        // Decoder for V3ZoneInfo
        Decoders.addDecoder(clazz: V3ZoneInfo.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<V3ZoneInfo> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? V3ZoneInfo() : instance as! V3ZoneInfo
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["MinZone"] as AnyObject?) {
                case let .success(value): _result.minZone = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["MaxZone"] as AnyObject?) {
                case let .success(value): _result.maxZone = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["UniqueZones"] as AnyObject?) {
                case let .success(value): _result.uniqueZones = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "V3ZoneInfo", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
